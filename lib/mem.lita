@include("<stdlib.h>");
@include("<string.h>");

import "clib" as c;


// TODO: should we remove this, there is clib now...
@foreign public func malloc(size: u64) : void*;
@foreign public func realloc(ptr:void*, size: u64) : void*;
@foreign public func calloc(num: u64, size: u64) : void*;
@foreign public func free(ptr:void*) : void;

@foreign public func memset(ptr: void*, value: i32, len: u64) : void*;
@foreign public func memcpy (dest: void*, src: void const*, num: u64) : void*;
@foreign public func memmove (dest: void*, src: void const*, num: u64) : void*;



/**
=========================================================
// new allocates a type T
=========================================================
*/
public func new<T>(a: Allocator const* = cAllocator) : T* {        
    return a.alloc(sizeof(T)) as (T*)
}

/**
=========================================================
// Duplicates the supplied memory
=========================================================
*/
public func memduplicate(p: void const*, len: u64, a: Allocator const* = cAllocator) : void* {    
    var copy = a.alloc(len)
    memcpy(copy, p, len)

    return copy
}


/**
=========================================================
// Allocator interface
=========================================================
*/
public struct Allocator {
    allocFn:   func(Allocator const*, u64): void*
    callocFn:  func(Allocator const*, u64, u64): void*
    reallocFn: func(Allocator const*, void*, u64, u64) : void*
    freeFn:    func(Allocator const*, void*) : void
}

@inline
public func (a: Allocator const*) alloc(size: u64) : void* {
    return a.allocFn(a, size)
}

@inline
public func (a: Allocator const*) calloc(num: u64, size: u64) : void* {
    return a.callocFn(a, num, size)
}

@inline
public func (a: Allocator const*) realloc(ptr: void*, oldsize: u64, newsize: u64) : void* {
    return a.reallocFn(a, ptr, oldsize, newsize)
}

@inline
public func (a: Allocator const*) free(ptr: void*) {
    return a.freeFn(a, ptr)
}







/**
=========================================================
// Default C Library allocator
=========================================================
*/
public const cAllocator : Allocator const* = (&Allocator {
    .allocFn:   &cMalloc,
    .callocFn:  &cCalloc,
    .reallocFn: &cRealloc,
    .freeFn:    &cFree
}) as (Allocator const*);

func cMalloc(a: Allocator const*, size: u64) : void* {
    return malloc(size);
}

func cCalloc(a: Allocator const*, num: u64, size: u64) : void* {
    return calloc(num, size);
}

func cRealloc(a: Allocator const*, ptr: void*, oldSize: u64, size: u64) : void* {
    return realloc(ptr, size);
}

func cFree(a: Allocator const*, ptr: void*) {
    return free(ptr)
}



/**
=========================================================
// Arena allocator
=========================================================
*/
public struct Arena {
    alloc: Allocator
    decorated: Allocator const*
    region: u8*
    size: u64
    current: u64
    next: Arena*
}

const PAGE_SIZE = 4096_u64

public func (arena: Arena*) init(size: u64 = PAGE_SIZE, alloc: Allocator const* = cAllocator) {
    arena.decorated = alloc
    arena.region = alloc.calloc(size, sizeof(u8)) as (u8*)
    arena.size = size
    arena.alloc = Allocator {
        .allocFn:   &ArenaMalloc,
        .callocFn:  &ArenaCalloc,
        .reallocFn: &ArenaRealloc,
        .freeFn:    &ArenaFree
    }
}

public func (arena: Arena*) free() {
    var alloc = arena.decorated

    var next: Arena* = null
    var last = arena.next;
    if(last == null) {
        return;
    }
    
    do {
        next = last.next
        alloc.free(last.region as (void*))
        alloc.free(last as (void*))
        last = next
    }
    while(next != null)
}

public func (arena: Arena*) malloc(size: u64) : void* {
    var a = arena
    var last = arena
    
    do {
        if((a.size - a.current) > size) {
            a.current += size
            return (a.region + (a.current - size)) as (void*)
        }

        last = a
    }
    while((a = a.next) != null);

    var asize = size > PAGE_SIZE ? size : PAGE_SIZE    
    var next = new<Arena>(arena.decorated)
    next.init(asize, arena.decorated)

    last.next = next
    next.current += size
    return next.region as (void*)
}

func ArenaMalloc(alloc: Allocator const*, size: u64) : void* {
    var arena = alloc as (Arena*);
    return arena.malloc(size);
}

func ArenaCalloc(alloc: Allocator const*, num: u64, size: u64) : void* {
    var arena = alloc as (Arena*);
    var result = arena.malloc(size * num);
    if(result) {
        memset(result, 0, size * num)
    }

    return result
}

func ArenaRealloc(alloc: Allocator const*, ptr: void*, oldSize: u64, size: u64) : void* {
    if(ptr == null) {
        return ArenaMalloc(alloc, size)
    }

    var arena = alloc as (Arena*);
    var result = arena.malloc(size);
    if(result) {
        var len = c::MIN(oldSize, size)
        memcpy(result, ptr, len)
    }

    return result

}

func ArenaFree(alloc: Allocator const*, ptr: void*) {
    // do nothing
}
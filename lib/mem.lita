@include("<stdlib.h>");
@include("<string.h>");

import "libc" as c;
import "array";


// TODO: should we remove this, there is clib now...
@foreign public func malloc(size: u64) : *void;
@foreign public func realloc(ptr:*void, size: u64) : *void;
@foreign public func calloc(num: u64, size: u64) : *void;
@foreign public func free(ptr:*void) : void;

@foreign public func memset(ptr: *void, value: i32, len: u64) : *void;
@foreign public func memcpy (dest: *void, src: *const void, num: u64) : *void;
@foreign public func memmove (dest: *void, src: *const void, num: u64) : *void;



/**
=========================================================
// new allocates a type T
=========================================================
*/

#if (options.debugMode) 

    public func new<T>(a: *const Allocator = defaultAllocator, file: *const char = __FILE__, line: u64 = __LINE__) : *T {        
        return a.alloc(sizeof(:T), file, line) as (*T)
    }

#else 

    public func new<T>(a: *const Allocator = defaultAllocator) : *T {        
        return a.alloc(sizeof(:T)) as (*T)
    }

#end

/**
=========================================================
// Duplicates the supplied memory
=========================================================
*/
public func memduplicate(p: *const void, len: u64, a: *const Allocator = defaultAllocator) : *void {    
    var copy = a.alloc(len)
    memcpy(copy, p, len)

    return copy
}


/**
=========================================================
// Allocator interface
=========================================================
*/

#if (options.debugMode) 

    @foreign
    public const __FILE__: *const char;

    @foreign
    public const __LINE__: u64;

    public struct Allocator {
        allocFn:   func(*const Allocator, u64, *const char, u64): *void
        callocFn:  func(*const Allocator, u64, u64, *const char, u64): *void
        reallocFn: func(*const Allocator, *void, u64, u64, *const char, u64) : *void
        freeFn:    func(*const Allocator, *void) : void
    }

    @inline
    public func (a: *const Allocator) alloc(size: u64, file: *const char = __FILE__, line: u64 = __LINE__) : *void {
        return a.allocFn(a, size, file, line)
    }

    @inline
    public func (a: *const Allocator) calloc(num: u64, size: u64, file: *const char = __FILE__, line: u64 = __LINE__) : *void {
        return a.callocFn(a, num, size, file, line)
    }

    @inline
    public func (a: *const Allocator) realloc(ptr: *void, oldsize: u64, newsize: u64, file: *const char = __FILE__, line: u64 = __LINE__) : *void {
        return a.reallocFn(a, ptr, oldsize, newsize, file, line)
    }

    @inline
    public func (a: *const Allocator) free(ptr: *void) {
        return a.freeFn(a, ptr)
    }

#else 

    public struct Allocator {
        allocFn:   func(*const Allocator, u64): *void
        callocFn:  func(*const Allocator, u64, u64): *void
        reallocFn: func(*const Allocator, *void, u64, u64) : *void
        freeFn:    func(*const Allocator, *void) : void
    }

    @inline
    public func (a: *const Allocator) alloc(size: u64) : *void {
        return a.allocFn(a, size)
    }

    @inline
    public func (a: *const Allocator) calloc(num: u64, size: u64) : *void {
        return a.callocFn(a, num, size)
    }

    @inline
    public func (a: *const Allocator) realloc(ptr: *void, oldsize: u64, newsize: u64) : *void {
        return a.reallocFn(a, ptr, oldsize, newsize)
    }

    @inline
    public func (a: *const Allocator) free(ptr: *void) {
        return a.freeFn(a, ptr)
    }

#end






/**
=========================================================
// C Library allocator
=========================================================
*/
public const cAllocator : *const Allocator = (&Allocator {
    .allocFn:   &cMalloc,
    .callocFn:  &cCalloc,
    .reallocFn: &cRealloc,
    .freeFn:    &cFree
}) as (*const Allocator);

#if (options.debugMode)

    func cMalloc(a: *const Allocator, size: u64, file: *const char = __FILE__, line: u64 = __LINE__) : *void {
        return malloc(size);
    }

    func cCalloc(a: *const Allocator, num: u64, size: u64, file: *const char = __FILE__, line: u64 = __LINE__) : *void {
        return calloc(num, size);
    }

    func cRealloc(a: *const Allocator, ptr: *void, oldSize: u64, size: u64, file: *const char = __FILE__, line: u64 = __LINE__) : *void {
        return realloc(ptr, size);
    }

    func cFree(a: *const Allocator, ptr: *void) {
        return free(ptr)
    }


#else 

    func cMalloc(a: *const Allocator, size: u64) : *void {
        return malloc(size);
    }

    func cCalloc(a: *const Allocator, num: u64, size: u64) : *void {
        return calloc(num, size);
    }

    func cRealloc(a: *const Allocator, ptr: *void, oldSize: u64, size: u64) : *void {
        return realloc(ptr, size);
    }

    func cFree(a: *const Allocator, ptr: *void) {
        return free(ptr)
    }

#end


/**
=========================================================
// Arena allocator
=========================================================
*/
public struct Arena {
    alloc: Allocator
    decorated: *const Allocator
    region: *u8
    size: u64
    current: u64
    next: *Arena
}

const PAGE_SIZE = 4096_u64

public func (arena: *Arena) init(size: u64 = PAGE_SIZE, alloc: *const Allocator = defaultAllocator) {
    arena.decorated = alloc
    arena.region = alloc.calloc(size, sizeof(:u8)) as (*u8)
    arena.current = 0
    arena.size = size
    arena.next = null
    arena.alloc = Allocator {
        .allocFn:   &ArenaMalloc,
        .callocFn:  &ArenaCalloc,
        .reallocFn: &ArenaRealloc,
        .freeFn:    &ArenaFree
    }
}

public func (arena: *Arena) free() {
    var alloc = arena.decorated
    alloc.free(arena.region as (*void))

    var next: *Arena = null
    var last = arena.next;
    
    if(last == null) {
        return;
    }

    do {
        next = last.next
        alloc.free(last.region as (*void))
        alloc.free(last as (*void))
        last = next
    }
    while(next != null)
}


#if (options.debugMode)
    public func (arena: *Arena) malloc(size: u64, file: *const char = __FILE__, line: u64 = __LINE__) : *void {
        var a = arena
        var last = arena
        
        do {
            if((a.size - a.current) > size) {
                a.current += size
                return (a.region + (a.current - size)) as (*void)
            }

            last = a
        }
        while((a = a.next) != null);

        var asize = size > PAGE_SIZE ? size : PAGE_SIZE    
        var next = new<Arena>(arena.decorated, file, line)
        next.init(asize, arena.decorated)

        last.next = next
        next.current += size
        return next.region as (*void)
    }


    func ArenaMalloc(alloc: *const Allocator, size: u64, file: *const char = __FILE__, line: u64 = __LINE__) : *void {
        var arena = alloc as (*Arena);
        return arena.malloc(size);
    }

    func ArenaCalloc(alloc: *const Allocator, num: u64, size: u64, file: *const char = __FILE__, line: u64 = __LINE__) : *void {
        var arena = alloc as (*Arena);
        var result = arena.malloc(size * num);
        if(result) {
            memset(result, 0, size * num)
        }

        return result
    }

    func ArenaRealloc(alloc: *const Allocator, ptr: *void, oldSize: u64, size: u64, file: *const char = __FILE__, line: u64 = __LINE__) : *void {
        if(ptr == null) {
            return ArenaMalloc(alloc, size)
        }

        var arena = alloc as (*Arena);

        var result = arena.malloc(size);
        if(result) {
            var len = c::MIN(oldSize, size)
            memcpy(result, ptr, len)

            ArenaFree(alloc, ptr)
        }

        return result

    }

#else

    public func (arena: *Arena) malloc(size: u64) : *void {
        var a = arena
        var last = arena
        
        do {
            if((a.size - a.current) > size) {
                a.current += size
                return (a.region + (a.current - size)) as (*void)
            }

            last = a
        }
        while((a = a.next) != null);

        var asize = size > PAGE_SIZE ? size : PAGE_SIZE    
        var next = new<Arena>(arena.decorated)
        next.init(asize, arena.decorated)

        last.next = next
        next.current += size
        return next.region as (*void)
    }

    func ArenaMalloc(alloc: *const Allocator, size: u64) : *void {
        var arena = alloc as (*Arena);
        return arena.malloc(size);
    }

    func ArenaCalloc(alloc: *const Allocator, num: u64, size: u64) : *void {
        var arena = alloc as (*Arena);
        var result = arena.malloc(size * num);
        if(result) {
            memset(result, 0, size * num)
        }

        return result
    }

    func ArenaRealloc(alloc: *const Allocator, ptr: *void, oldSize: u64, size: u64) : *void {
        if(ptr == null) {
            return ArenaMalloc(alloc, size)
        }

        var arena = alloc as (*Arena);

        var result = arena.malloc(size);
        if(result) {
            var len = c::MIN(oldSize, size)
            memcpy(result, ptr, len)

            ArenaFree(alloc, ptr)
        }

        return result

    }

#end

func ArenaFree(alloc: *const Allocator, ptr: *void) {
    // do nothing
}





/**
=========================================================
// Debug Leak Detection allocator
=========================================================
*/
const MAX_PATH = 256
public struct Allocation {
    addr: *void
    size: u64
    line: u64
    filename: [MAX_PATH]char
}

public struct DebugAllocator {
    alloc: Allocator
    decorated: *const Allocator
    allocations: Array<*Allocation>    
}

public const debugAllocator = (&DebugAllocator {
})

public func (d: *DebugAllocator) init(alloc: *const Allocator = defaultAllocator) {
    d.alloc = Allocator {
        .allocFn:   &DebugMalloc,
        .callocFn:  &DebugCalloc,
        .reallocFn: &DebugRealloc,
        .freeFn:    &DebugFree
    }
    d.decorated = alloc    
    d.allocations.init(128, alloc)
}

public func (d: *DebugAllocator) free() {
    d.allocations.free()
}

public func (d: *DebugAllocator) report() {
    c::printf("Leaked Allocations: {\n")
    for(var i = 0; i < d.allocations.size(); i += 1) {
        var a = d.allocations.get(i)
        c::printf("   Leak at %p allocated in '%s' at line: %ju\n", a.addr, a.filename, a.line)
    }
    c::printf("}\n")
}

public func (d: *DebugAllocator) malloc(size: u64, file: *const char, line: u64) : *void {
    var mem = d.decorated.alloc(size)
    if(mem) {
        var allocation = new<Allocation>(d.decorated);
        allocation.addr = mem
        allocation.size = size
        allocation.line = line        
        c::strncpy(allocation.filename, file, MAX_PATH)

        d.allocations.add(allocation)
    }

    return mem;
}

#if (options.debugMode)
    func DebugMalloc(alloc: *const Allocator, size: u64, file: *const char = __FILE__, line: u64 = __LINE__) : *void {
        var debug = alloc as (*DebugAllocator);
        return debug.malloc(size, file, line);
    }

    func DebugCalloc(alloc: *const Allocator, num: u64, size: u64, file: *const char = __FILE__, line: u64 = __LINE__) : *void {
        var debug = alloc as (*DebugAllocator);
        var result = debug.malloc(size * num, file, line);
        if(result) {
            memset(result, 0, size * num)
        }

        return result
    }

    func DebugRealloc(alloc: *const Allocator, ptr: *void, oldSize: u64, size: u64, file: *const char = __FILE__, line: u64 = __LINE__) : *void {
        if(ptr == null) {
            return DebugMalloc(alloc, size)
        }

        var debug = alloc as (*DebugAllocator);

        var result = debug.malloc(size, file, line);
        if(result) {
            var len = c::MIN(oldSize, size)
            memcpy(result, ptr, len)

            DebugFree(alloc, ptr)
        }

        return result    
    }

#else 

    func DebugMalloc(alloc: *const Allocator, size: u64) : *void {
        var debug = alloc as (*DebugAllocator);
        return debug.malloc(size, "", 0);
    }

    func DebugCalloc(alloc: *const Allocator, num: u64, size: u64) : *void {
        var debug = alloc as (*DebugAllocator);
        var result = debug.malloc(size * num, "", 0);
        if(result) {
            memset(result, 0, size * num)
        }

        return result
    }

    func DebugRealloc(alloc: *const Allocator, ptr: *void, oldSize: u64, size: u64) : *void {
        if(ptr == null) {
            return DebugMalloc(alloc, size)
        }

        var debug = alloc as (*DebugAllocator);

        var result = debug.malloc(size, "", 0);
        if(result) {
            var len = c::MIN(oldSize, size)
            memcpy(result, ptr, len)

            DebugFree(alloc, ptr)
        }

        return result    
    }

#end

func DebugFree(alloc: *const Allocator, ptr: *void) {
    if(ptr == null) {
        return;
    }

    var debug = alloc as (*DebugAllocator);
    var addr = ptr;

    var found = false
    for(var i = 0; i < debug.allocations.size();) {
        var allocation = debug.allocations.get(i)
        if(allocation.addr == addr) {
            debug.allocations.removeAt(i)
            debug.decorated.free(allocation)
            found = true
        }
        else {
            i += 1
        }
    }

    if(!found) {
        c::printf("Allocation not found: %p\n", ptr)
    }

    debug.decorated.free(ptr)
}



/**
=========================================================
// Default allocator
=========================================================
*/

#if (options.debugMode)

   // @threadlocal 
    // TODO: This isn't thread safe :(
    public var defaultAllocator: *const Allocator = (&DebugAllocator {
    }) as (*const Allocator);

    @module_init
    func ModuleInit() {
        var debugAllocator = defaultAllocator as (*DebugAllocator)
        debugAllocator.init(cAllocator);
        //c::printf("Module Init!\n")
    }

    @module_destroy
    func ModuleDestroy() {
        var debugAllocator = defaultAllocator as (*DebugAllocator)
        debugAllocator.report(); 
        debugAllocator.free(); 
        //c::printf("Module Destroy!\n")
    }

#else

    @threadlocal 
    public var defaultAllocator: *const Allocator = (&Allocator {
            .allocFn:   &cMalloc,
            .callocFn:  &cCalloc,
            .reallocFn: &cRealloc,
            .freeFn:    &cFree
        }) as (*const Allocator);

#end

@include("<stdlib.h>");
@include("<string.h>");

import "clib" as c;
import "array";


// TODO: should we remove this, there is clib now...
@foreign public func malloc(size: u64) : void*;
@foreign public func realloc(ptr:void*, size: u64) : void*;
@foreign public func calloc(num: u64, size: u64) : void*;
@foreign public func free(ptr:void*) : void;

@foreign public func memset(ptr: void*, value: i32, len: u64) : void*;
@foreign public func memcpy (dest: void*, src: void const*, num: u64) : void*;
@foreign public func memmove (dest: void*, src: void const*, num: u64) : void*;



/**
=========================================================
// new allocates a type T
=========================================================
*/
public func new<T>(a: Allocator const* = defaultAllocator) : T* {        
    return a.alloc(sizeof(T)) as (T*)
}

/**
=========================================================
// Duplicates the supplied memory
=========================================================
*/
public func memduplicate(p: void const*, len: u64, a: Allocator const* = defaultAllocator) : void* {    
    var copy = a.alloc(len)
    memcpy(copy, p, len)

    return copy
}


/**
=========================================================
// Allocator interface
=========================================================
*/
public struct Allocator {
    allocFn:   func(Allocator const*, u64): void*
    callocFn:  func(Allocator const*, u64, u64): void*
    reallocFn: func(Allocator const*, void*, u64, u64) : void*
    freeFn:    func(Allocator const*, void*) : void
}

@inline
public func (a: Allocator const*) alloc(size: u64) : void* {
    return a.allocFn(a, size)
}

@inline
public func (a: Allocator const*) calloc(num: u64, size: u64) : void* {
    return a.callocFn(a, num, size)
}

@inline
public func (a: Allocator const*) realloc(ptr: void*, oldsize: u64, newsize: u64) : void* {
    return a.reallocFn(a, ptr, oldsize, newsize)
}

@inline
public func (a: Allocator const*) free(ptr: void*) {
    return a.freeFn(a, ptr)
}







/**
=========================================================
// C Library allocator
=========================================================
*/
public const cAllocator : Allocator const* = (&Allocator {
    .allocFn:   &cMalloc,
    .callocFn:  &cCalloc,
    .reallocFn: &cRealloc,
    .freeFn:    &cFree
}) as (Allocator const*);

func cMalloc(a: Allocator const*, size: u64) : void* {
    return malloc(size);
}

func cCalloc(a: Allocator const*, num: u64, size: u64) : void* {
    return calloc(num, size);
}

func cRealloc(a: Allocator const*, ptr: void*, oldSize: u64, size: u64) : void* {
    return realloc(ptr, size);
}

func cFree(a: Allocator const*, ptr: void*) {
    return free(ptr)
}



/**
=========================================================
// Arena allocator
=========================================================
*/
public struct Arena {
    alloc: Allocator
    decorated: Allocator const*
    region: u8*
    size: u64
    current: u64
    next: Arena*
}

const PAGE_SIZE = 4096_u64

public func (arena: Arena*) init(size: u64 = PAGE_SIZE, alloc: Allocator const* = defaultAllocator) {
    arena.decorated = alloc
    arena.region = alloc.calloc(size, sizeof(u8)) as (u8*)
    arena.current = 0
    arena.size = size
    arena.next = null
    arena.alloc = Allocator {
        .allocFn:   &ArenaMalloc,
        .callocFn:  &ArenaCalloc,
        .reallocFn: &ArenaRealloc,
        .freeFn:    &ArenaFree
    }
}

public func (arena: Arena*) free() {
    var alloc = arena.decorated
    alloc.free(arena.region as (void*))

    var next: Arena* = null
    var last = arena.next;
    
    if(last == null) {
        return;
    }

    do {
        next = last.next
        alloc.free(last.region as (void*))
        alloc.free(last as (void*))
        last = next
    }
    while(next != null)
}

public func (arena: Arena*) malloc(size: u64) : void* {
    var a = arena
    var last = arena
    
    do {
        if((a.size - a.current) > size) {
            a.current += size
            return (a.region + (a.current - size)) as (void*)
        }

        last = a
    }
    while((a = a.next) != null);

    var asize = size > PAGE_SIZE ? size : PAGE_SIZE    
    var next = new<Arena>(arena.decorated)
    next.init(asize, arena.decorated)

    last.next = next
    next.current += size
    return next.region as (void*)
}

func ArenaMalloc(alloc: Allocator const*, size: u64) : void* {
    var arena = alloc as (Arena*);
    return arena.malloc(size);
}

func ArenaCalloc(alloc: Allocator const*, num: u64, size: u64) : void* {
    var arena = alloc as (Arena*);
    var result = arena.malloc(size * num);
    if(result) {
        memset(result, 0, size * num)
    }

    return result
}

func ArenaRealloc(alloc: Allocator const*, ptr: void*, oldSize: u64, size: u64) : void* {
    if(ptr == null) {
        return ArenaMalloc(alloc, size)
    }

    var arena = alloc as (Arena*);

    var result = arena.malloc(size);
    if(result) {
        var len = c::MIN(oldSize, size)
        memcpy(result, ptr, len)

        ArenaFree(alloc, ptr)
    }

    return result

}

func ArenaFree(alloc: Allocator const*, ptr: void*) {
    // do nothing
}





/**
=========================================================
// Debug Leak Detection allocator
=========================================================
*/
const MAX_PATH = 256
public struct Allocation {
    addr: void*
    size: u64
    line: u64
    filename: [MAX_PATH]char
}

public struct DebugAllocator {
    alloc: Allocator
    decorated: Allocator const*
    allocations: Array<Allocation*>    
}

public const debugAllocator = (&DebugAllocator {
})

public func (d: DebugAllocator*) init(alloc: Allocator const* = defaultAllocator) {
    d.alloc = Allocator {
        .allocFn:   &DebugMalloc,
        .callocFn:  &DebugCalloc,
        .reallocFn: &DebugRealloc,
        .freeFn:    &DebugFree
    }
    d.decorated = alloc    
    d.allocations.init(128, alloc)
}

public func (d: DebugAllocator*) free() {
    d.allocations.free()
}

public func (d: DebugAllocator*) report() {
    for(var i = 0; i < d.allocations.size(); i += 1) {
        var a = d.allocations.get(i)
        c::printf("Leak at %p allocated in '%s' at line: %llu\n", a.addr, a.filename, a.line)
    }
}

public func (d: DebugAllocator*) malloc(size: u64) : void* {
    var mem = d.decorated.alloc(size)
    if(mem) {
        var allocation = new<Allocation>(d.decorated);
        allocation.addr = mem
        allocation.size = size
        allocation.line = 0 // TODO __LINE__
        memset(allocation.filename, 0, MAX_PATH) // TODO __FILE__

        d.allocations.add(allocation)
        // TODO: add line/file default params (use compIf)
    }

    return mem;
}

func DebugMalloc(alloc: Allocator const*, size: u64) : void* {
    var debug = alloc as (DebugAllocator*);
    return debug.malloc(size);
}

func DebugCalloc(alloc: Allocator const*, num: u64, size: u64) : void* {
    var debug = alloc as (DebugAllocator*);
    var result = debug.malloc(size * num);
    if(result) {
        memset(result, 0, size * num)
    }

    return result
}

func DebugRealloc(alloc: Allocator const*, ptr: void*, oldSize: u64, size: u64) : void* {
    if(ptr == null) {
        return DebugMalloc(alloc, size)
    }

    var debug = alloc as (DebugAllocator*);

    var result = debug.malloc(size);
    if(result) {
        var len = c::MIN(oldSize, size)
        memcpy(result, ptr, len)

        DebugFree(alloc, ptr)
    }

    return result    
}

func DebugFree(alloc: Allocator const*, ptr: void*) {
    if(ptr == null) {
        return;
    }

    var debug = alloc as (DebugAllocator*);
    var addr = ptr;

    var found = false
    for(var i = 0; i < debug.allocations.size();) {
        var allocation = debug.allocations.get(i)
        if(allocation.addr == addr) {
            debug.allocations.removeAt(i)
            debug.decorated.free(allocation)
            found = true
        }
        else {
            i += 1
        }
    }

    if(!found) {
        c::printf("Allocation not found: %p\n", ptr)
    }

    debug.decorated.free(ptr)
}



/**
=========================================================
// Default allocator
=========================================================
*/
@threadlocal // TODO: Compile time IF statements
public var defaultAllocator: Allocator const* = (&Allocator {
    .allocFn:   &cMalloc,
    .callocFn:  &cCalloc,
    .reallocFn: &cRealloc,
    .freeFn:    &cFree
}) as (Allocator const*);

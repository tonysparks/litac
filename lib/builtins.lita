@raw("""

#if _MSC_VER
#define LITAC_THREADLOCAL __declspec(thread)
#define LITAC_INLINE static inline __forceinline
#define LITAC_NOINLINE __declspec(noinline)
#define LITAC_PACKED __pragma(pack(push, 1))
#define LITAC_PACKED_POP __pragma(pack(pop))
#define LITAC_EXPORT __declspec(dllexport)
#endif

#if __GNUC__
#define LITAC_THREADLOCAL __thread
#define LITAC_INLINE static inline __attribute__((always_inline))
#define LITAC_NOINLINE __attribute__((noinline))
#define LITAC_PACKED __attribute__((packed))
#define LITAC_PACKED_POP
#define LITAC_EXPORT __attribute__((visibility("default")))
#endif
""");


#if (REFLECTION)
    import "type";
#end


/**
    Compiler script to generate Enum AsStr functions when they are noted with 'asStr'.

    Example:
    @asStr("TestAsString")
    enum Test {
        ONE,

        @asStr("DOS")
        TWO,
    }

    Will create this function:

    func TestAsString(type: Test) : *const char {
        switch(type) {
            case Test.ONE: return "ONE";
            case Test.TWO: return "DOS";
            default: return null;
        }
    }
*/
#precheck
    for(sym in getSymbolsByNote("asStr")) {
        if(sym.kind == "ENUM_DECL") {
            emitClear()
            var symName = ""

            // Look to see if there is a custom name in the enums note
            if(sym.notes) {
                for(note in sym.notes) {
                    if(note.name == "asStr" && note.attributes) {
                        symName = note.attributes[0].name
                    }
                }
            }

            if(symName == "") {
                symName = concat(sym.name, "AsStr")
            }

            if(sym.isPublic) {
                emit("public ")
            }
            emit("func %s(enumType: %s) : *const char {
                      switch(enumType) {\n", symName, sym.name);
            for(field in sym.enumDecl.fields) {
                var fieldName = field.name

                // Look to see if there is a custom name for the field
                if(field.notes) {
                    for(note in field.notes) {
                        if(note.name == "asStr" && note.attributes) {
                            fieldName = note.attributes[0].name
                        }
                    }
                }
                emit("        case %s.%s: return \"%s\";\n", sym.name, field.name, fieldName);
            }
            emit("        default: return null;
                      }
                }\n")

            addDeclaration(sym.moduleName, emitStr())
        }
    }
#end




/**
    Compiler script to inject module init and destroy functions; these
    function must be public in order for them to be accessible to the
    main function

    Example:
    @module_init
    public func moduleInitialize() {

    }

    @module_destroy
    public func moduleInitialize() {

    }

    Will modify the main function to:

    func main(argc:i32, args:**char) : i32 {
        moduleInitialize()
        defer moduleDestroy()
        // main code
    }
*/
#precheck
    var mainSym = getMainSymbol()

    for(sym in getSymbolsByNote("module_init")) {
        if(sym.kind == "FUNC_DECL" && sym.isPublic) {
            var alias = addImport(mainSym.moduleName, sym.moduleName)
            if(alias) {
                emitClear()
                emit("defer %s::%s()", alias, sym.name)
                astInsert(mainSym.declPtr, emitStr(), 0)

                emitClear()
                emit("%s::%s()", alias, sym.name)
                astInsert(mainSym.declPtr, emitStr(), 0)
            }
            else {

                emitClear()
                emit("defer %s()", sym.name)
                astInsert(mainSym.declPtr, emitStr(), 0)

                emitClear()
                emit("%s()", sym.name)
                astInsert(mainSym.declPtr, emitStr(), 0)
            }
        }

    }
#end


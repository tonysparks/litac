import "mem";

@include("<stdio.h>");
@include("<stdlib.h>");

@foreign public struct FILE;
@foreign public func printf(s:*const char, ...) : void;
@foreign public func fopen(fileName:*const char, openType:*const char) : *FILE;
@foreign public func fgets(buf: *char, n:i64, stream: *FILE): *char;
@foreign public func fread(buf: *void, size:u64, n:u64, stream: *FILE) : u64;
@foreign public func fwrite(buf: *const void, sizeOfElements: u64, numOfElements:u64, stream: *FILE) : u64;
@foreign public func fclose(stream: *FILE) : void;
@foreign public func fseek(stream: *FILE, offset : i64, whence : i32) : i32;
@foreign public func ftell(stream: *FILE) : i64;
@foreign public func ferror(stream: *FILE) : i32;

// TODO allow const to be undefined
@foreign public var SEEK_SET : i32;
@foreign public var SEEK_CUR : i32;
@foreign public var SEEK_END : i32;

@asStr
public enum FileStatus {
    Ok = 0,
    FileNotFoundError,
    IOError,
}

public func FileLength(fileName: *const char) : i64 {
    var fp = fopen(fileName, "r")
    if(fp == null) {
        return -1;
    }
    defer fclose(fp)

    if (fseek(fp, 0, SEEK_END)) {
        return -1;
    }
    
    const len = ftell(fp)
    return len;
}

public func ReadFile(fileName: *const char, data: **char, alloc: *const Allocator = defaultAllocator) : FileStatus { 

    var fp = fopen(fileName, "r")
    if(fp == null) {
        return FileStatus.FileNotFoundError;
    }
    defer fclose(fp)

    if (fseek(fp, 0, SEEK_END)) {
        return FileStatus.IOError;
    }
    
    const len = ftell(fp)
    if(len < 0_i64) {
        return FileStatus.IOError;
    }
    
    if (fseek(fp, 0, SEEK_SET)) {
        return FileStatus.IOError;
    }
    
    var buf = alloc.alloc(sizeof(:char) * (len as(u64) + 1_u64)) as (*char);
    (*data) = buf;

    // stupid Windows and /r/n, the newLen will be different than that of ftell
    var newLen = fread(buf, sizeof(:char), len, fp);
    if(ferror(fp)) {
        return FileStatus.IOError;
    }
    
    buf[newLen] = '\0';
    return FileStatus.Ok;

}

public func WriteFile(fileName: *const char, buffer: *const char, len: u64) : FileStatus {
    var fp = fopen(fileName, "w")
    if(fp == null) {
        return FileStatus.FileNotFoundError;
    }
    defer fclose(fp)

    return WriteBytes(fp, buffer, len)
}

public func WriteBytes(fp: *FILE, buffer: *const char, len: u64) : FileStatus {    
    var bytesWritten = fwrite(buffer as (*const void), sizeof(:char), len, fp)
    if(bytesWritten != len) {
        return FileStatus.IOError;
    }

    return FileStatus.Ok
}
import "mem" as mem;
import "assert";
import "io";
import "string_buffer";
import "map";
import "array";

@include("<ctype.h>");
@include("<stdlib.h>");
@include("<math.h>");

@foreign const HUGE_VAL: f64;
@foreign const ULLONG_MAX: i64;
@foreign func isdigit(arg: i32) : i32;
@foreign func tolower(arg: i32) : i32;
@foreign func isalnum(arg: i32) : i32;
@foreign func isspace(arg: i32) : i32;

@foreign func strtod(str: char const*, end: char**) : f64;

@foreign struct va_list;
@foreign func va_start(args: va_list, format: char const*);
@foreign func va_end(args: va_list);
@foreign const stderr : FILE*;
@foreign const stdout : FILE*;
@foreign func vfprintf(f:FILE*, format: char const*, args: va_list);

@asStr
public enum JsonType {
    NULL,
    BOOLEAN,
    NUMBER,
    STRING,
    OBJECT,
    ARRAY,
}

public typedef Array<JsonNode*> as JsonArray;
public typedef Map<char const*, JsonNode*> JsonObject;

public union JsonValue {
    boolValue: bool
    doubleValue: f64
    strValue: char const*

    objValue: JsonObject*
    arrayValue: JsonArray*
}

public struct JsonNode {
    alloc: mem::Allocator const*
    type: JsonType
    value: using JsonValue    
}

@inline
public func (node: JsonNode*) isNull() : bool {
    return node.type == JsonType.NULL
}

@inline
public func (node: JsonNode*) isBool() : bool {
    return node.type == JsonType.BOOLEAN
}

@inline
public func (node: JsonNode*) isTrue() : bool {
    return node.type == JsonType.BOOLEAN && node.value.boolValue
}

@inline
public func (node: JsonNode*) isFalse() : bool {
    return !node.isTrue()
}

@inline
public func (node: JsonNode*) isNumber() : bool {
    return node.type == JsonType.NUMBER
}
@inline
public func (node: JsonNode*) isString() : bool {
    return node.type == JsonType.STRING
}

@inline
public func (node: JsonNode*) isArray() : bool {
    return node.type == JsonType.ARRAY
}

@inline
public func (node: JsonNode*) isObject() : bool {
    return node.type == JsonType.OBJECT
}

@inline
public func (node: JsonNode*) asString() : char const* {
    return node.value.strValue
}

@inline
public func (node: JsonNode*) asBool() : bool {
    return node.value.boolValue
}

@inline
public func (node: JsonNode*) asNumber() : f64 {
    return node.value.doubleValue
}

@inline
public func (node: JsonNode*) asArray() : JsonArray* {
    return node.value.arrayValue
}

@inline
public func (node: JsonNode*) asObject() : JsonObject* {
    return node.value.objValue
}

public func CreateJsonNumber(value: f64, alloc: mem::Allocator const* = mem::cAllocator) : JsonNode* {    
    var node = mem::new<JsonNode>(alloc)
    node.alloc = alloc
    node.type = JsonType.NUMBER
    node.value = JsonValue {
        .doubleValue = value
    }

    return node
}

public func CreateJsonString(str: char const*, len: i32, alloc: mem::Allocator const* = mem::cAllocator) : JsonNode* {    
    var node = mem::new<JsonNode>(alloc)
    node.alloc = alloc
    node.type = JsonType.NUMBER

    var copy = mem::memduplicate(str as (void const*), len + 1, alloc) as (char*)
    copy[len] = '\0'

    node.value = JsonValue {
        .strValue = copy
    }

    return node
}

public func CreateJsonArray(alloc: mem::Allocator const* = mem::cAllocator) : JsonNode* {    
    var node = mem::new<JsonNode>(alloc)
    node.alloc = alloc
    node.type = JsonType.ARRAY
    node.value = JsonValue {
        .arrayValue = mem::new<JsonArray>(alloc)
    }
    
    node.value.arrayValue.init(16, alloc)

    return node
}

public func CreateJsonObject(alloc: mem::Allocator const* = mem::cAllocator) : JsonNode* {    
    var node = mem::new<JsonNode>(alloc)
    node.alloc = alloc
    node.type = JsonType.OBJECT
    node.value = JsonValue { 
        .objValue = mem::new<JsonObject>(alloc)   
    }

    node.value.objValue.init(null, 16, null, null, alloc)

    return node
}

public func (node: JsonNode*) free() {
    if(!node) {
        return;
    }

    var alloc = node.alloc

    // null,true,false don't have an allocator, we don't want to deallocate them
    // as they are globals
    if(!alloc) { 
        return;
    }

    switch(node.type) {
        case JsonType.ARRAY: {
            for(var i = 0; i < node.arrayValue.size(); i+=1) {
                var n = node.arrayValue.get(i)
                if(n) {
                    n.free()
                }
            }

            node.arrayValue.free()
            alloc.free(node.arrayValue as (void*))                    
            break;
        }
        case JsonType.OBJECT: {
            var it = node.objValue.iter()
            while(it.hasNext()) {
                var entry = it.next()
                var key = entry.key
                alloc.free(key as (void*))

                var n = entry.value
                if(n) {
                    n.free()
                }
            }
            node.objValue.free()
            alloc.free(node.objValue as (void*))                    
            break;
        }
        case JsonType.STRING: {
            alloc.free(node.strValue as (void*))
            break;
        }
        default:
    }

    alloc.free(node as (void*))
}



public const JSON_NULL = &JsonNode {
    .alloc: null,    
    .type: JsonType.NULL,
    .value: JsonValue {0},    
}

public const JSON_TRUE = &JsonNode {
    .alloc: null,
    .type: JsonType.BOOLEAN,
    .value: JsonValue {.boolValue = true},    
}

public const JSON_FALSE = &JsonNode {
    .alloc: null,    
    .type: JsonType.BOOLEAN,
    .value: JsonValue {.boolValue = false},    
}


enum TokenKind {
    EOF,    
    ERROR,
    COMMA,
    COLON,
    LEFT_BRACE,
    RIGHT_BRACE,
    LEFT_BRACKET,
    RIGHT_BRACKET,
    NULL,
    NUMBER,
    TRUE,
    FALSE,
    STRING,
}

const tokenKindNames = []char const* {
    [TokenKind.EOF] = "EOF",
    [TokenKind.ERROR] = "ERROR",
    [TokenKind.COMMA] = ",",
    [TokenKind.COLON] = ":",
    [TokenKind.LEFT_BRACE] = "{",
    [TokenKind.RIGHT_BRACE] = "}",
    [TokenKind.LEFT_BRACKET] = "[",
    [TokenKind.RIGHT_BRACKET] = "]",
    [TokenKind.NULL] = "null",
    [TokenKind.NUMBER] = "number",
    [TokenKind.TRUE] = "true",
    [TokenKind.FALSE] = "false",
    [TokenKind.STRING] = "string",
}


const charToDigit = [256]i32 {
    ['0'] = 0,
    ['1'] = 1,
    ['2'] = 2,
    ['3'] = 3,
    ['4'] = 4,
    ['5'] = 5,
    ['6'] = 6,
    ['7'] = 7,
    ['8'] = 8,
    ['9'] = 9,
    ['a'] = 10, ['A'] = 10,
    ['b'] = 11, ['B'] = 11,
    ['c'] = 12, ['C'] = 12,
    ['d'] = 13, ['D'] = 13,
    ['e'] = 14, ['E'] = 14,
    ['f'] = 15, ['F'] = 15,
};

const escapeToChar = [256]char {
    ['0'] = '\0',
    ['\''] = '\'',
    ['"'] = '"', 
    ['\\'] = '\\',
    ['n'] = '\n',
    ['r'] = '\r',
    ['t'] = '\t',
    //['v'] = '\v',
  //  ['b'] = '\b',
  //  ['a'] = '\a',
};


struct SrcPos {
    name: char const*
    line: i32
}

struct Token {
    kind: TokenKind
    pos: SrcPos
    start: char const*
    end: char const*

    union {
        numValue: f64
        strValue: char const*
        name: char const*
    }
}


public enum ParserStatus {
    OK = 0,
    WARNING,
    ERROR,
}

public typedef func(char const*, va_list) : void as PrintFn;

const MAX_MESSAGE_SIZE = 128

public struct Parser {
    alloc: mem::Allocator const*
    status: ParserStatus
    printFn: PrintFn

    token: Token
    buffer: StringBuffer
    stream: char const*
    lineStart: char const*
}

public func (p: Parser*) init(printFn: PrintFn, alloc: mem::Allocator const* = mem::cAllocator) {
    p.alloc = alloc
    p.status = ParserStatus.OK
    p.printFn = printFn

    p.stream = null
    p.lineStart = null
    p.token.pos.name = "<string>";
    p.token.pos.line = 1
    p.buffer.init(16)
}

public func (p: Parser*) free() {
    p.buffer.free()
    p.stream = null
    p.lineStart = null
}

public func (p: Parser*) parseJson(buffer: char const*) : JsonNode* {    
    p.stream = buffer
    p.lineStart = p.stream

    p.buffer.clear()
    p.nextToken()

    var node = p.parseJsonNode()    
    return node
}

public func PrintJson(node: JsonNode*, buf: StringBuffer*) {
    if(!node) {
        return;
    }

    //printf("Type: %s\n", JsonTypeAsStr(node.type))
    //printf("Buf: '%s'\n", buf.cStr())

    switch(node.type) {
        case JsonType.NULL: {
            buf.append("null")
            break;
        }
        case JsonType.BOOLEAN: {
            (node.boolValue) ?
                buf.append("true") : buf.append("false")
            break;
        }
        case JsonType.NUMBER: {
            buf.append("%f", node.doubleValue)
            break;
        }
        case JsonType.STRING: {
            buf.append("\"%s\"", node.strValue)
            break;
        }
        case JsonType.OBJECT: {
            buf.append("{")
            var obj = node.objValue

            var isFirst = true
            var it = obj.iter() 
            while(it.hasNext()) {
                var entry = it.next()

                if(!isFirst) buf.append(",")
                buf.append("\"%s\":", entry.key)
                PrintJson(entry.value, buf)
                isFirst = false
            }
            buf.append("}")
            break;
        }
        case JsonType.ARRAY: {
            buf.append("[")
            var array = node.arrayValue
            var isFirst = true
            for(var i = 0; i < array.size(); i+=1) {
                if(!isFirst) buf.append(",")
                PrintJson(array.get(i), buf)                
                isFirst = false
            }
            buf.append("]")
            break;
        }
    }
}



func (p: Parser*) parseJsonNode() : JsonNode* {    
    switch(p.token.kind) {
        case TokenKind.EOF: 
            return null;
        case TokenKind.ERROR:
            // TODO
            return null;
        case TokenKind.TRUE:
            p.nextToken()
            return JSON_TRUE
        case TokenKind.FALSE:
            p.nextToken()
            return JSON_FALSE
        case TokenKind.NULL:
            p.nextToken()
            return JSON_NULL
        case TokenKind.NUMBER:
            p.nextToken()
            return p.parseJsonNumber()            
        case TokenKind.STRING:
            p.nextToken()
            return p.parseJsonStr()
        case TokenKind.LEFT_BRACE:
            p.nextToken()
            return p.parseJsonObject()
        case TokenKind.LEFT_BRACKET:
            p.nextToken()
            return p.parseJsonArray()    
        default:        
    }

    return null
}

func (p: using Parser*) parseJsonNumber() : JsonNode* {
    var node = mem::new<JsonNode>(p.alloc)
    node.alloc = p.alloc
    node.type = JsonType.NUMBER
    node.value = JsonValue {
        .doubleValue = token.numValue
    }

    return node
}

func (p: using Parser*) parseJsonStr() : JsonNode* {
    var node = mem::new<JsonNode>(p.alloc)
    node.alloc = p.alloc
    node.type = JsonType.STRING
    node.value = JsonValue {
        .strValue = token.strValue        
    }

    return node    
}

func (p: using Parser*) parseJsonArray() : JsonNode* {
    var node = mem::new<JsonNode>(p.alloc)
    node.alloc = p.alloc
    node.type = JsonType.ARRAY
    node.value = JsonValue {
        .arrayValue = mem::new<JsonArray>(p.alloc)
    }
    
    node.value.arrayValue.init(16, p.alloc)

    do {
        if(p.check(TokenKind.RIGHT_BRACKET)) {
            break;
        }
        var element = p.parseJsonNode();
        node.value.arrayValue.add(element)    
    }
    while (p.match(TokenKind.COMMA));

    p.expect(TokenKind.RIGHT_BRACKET)
    return node     
}
func (p: using Parser*) parseJsonObject() : JsonNode* {
    var node = mem::new<JsonNode>(p.alloc)
    node.alloc = p.alloc
    node.type = JsonType.OBJECT
    node.value = JsonValue { 
        .objValue = mem::new<JsonObject>(p.alloc)   
    }

    node.value.objValue.init(null, 16, null, null, p.alloc)

    do {
        if(p.check(TokenKind.RIGHT_BRACE)) {
            break;
        }

        var key = p.token.strValue
        p.expect(TokenKind.STRING)

        p.expect(TokenKind.COLON)        
        var value = p.parseJsonNode();
        
        node.value.objValue.put(key, value)
    }
    while (p.match(TokenKind.COMMA));

    p.expect(TokenKind.RIGHT_BRACE)
    return node     
}

func TokenName(t: TokenKind) : char const* {
    return tokenKindNames[t]
}


func error(format: char const*, ...) {
    var args: va_list;
    va_start(args, format);
    
    vfprintf(stdout, format, args);            
    va_end(args);        
}

func fatalError(format: char const*, ...) {
    var args: va_list;
    va_start(args, format);
    
    vfprintf(stderr, format, args);            
    va_end(args);        
}

func (p: using Parser*) scanInt() {
    var base = 10;
    var start_digits = stream;
    if (*stream == '0') {
        stream += 1;
        if (tolower(*stream) == 'x') {
            stream += 1;
            base = 16;
            start_digits = stream;
        } else if (tolower(*stream) == 'b') {
            stream += 1;
            base = 2;
            start_digits = stream;
        } else if (isdigit(*stream)) {
            base = 8;
            start_digits = stream;
        }
    }
    var val: i64 = 0;
    for (;;) {
        if (*stream == '_') {
            stream += 1;
            continue;
        }
        var digit = charToDigit[(*stream) as (i32)];
        if (digit == 0 && *stream != '0') {
            break;
        }
        if (digit >= base) {
            error("Digit '%c' out of range for base %d\n", *stream, base);
            digit = 0;
        }
        if (val > (ULLONG_MAX - digit)/base) {
            error("Integer literal overflow\n");
            while (isdigit(*stream)) {
                stream += 1;
            }
            val = 0;
            break;
        }
        val = val*base + digit;
        stream += 1;
    }
    if (stream == start_digits) {
        error("Expected base %d digit, got '%c'\n", base, *stream);
    }
    token.kind = TokenKind.NUMBER; //TOKEN_INT;
    token.numValue = val;
}

func (p: using Parser*) scanFloat() {    
    var start = p.stream;

    while (isdigit(*stream)) {
        stream+=1;
    }
    if (*stream == '.') {
        stream+=1;
    }
    while (isdigit(*stream)) {
        stream+=1;
    }
    if (tolower(*stream) == 'e') {
        stream+=1;
        if (*stream == '+' || *stream == '-') {
            stream+=1;
        }
        if (!isdigit(*stream)) {
            error("Expected digit after float literal exponent, found '%c'.\n", *stream);
        }
        while (isdigit(*stream)) {
            stream+=1;
        }
    }
    var val = strtod(start, null);
    if (val == HUGE_VAL) {
        error("Float literal overflow\n");
    }
    token.kind = TokenKind.NUMBER;
    token.numValue = val;    
}

func (p: using Parser*) scanStr() {
    assert(*stream == '"'); // "
    stream+=1;    
    buffer.clear()

    while (*stream && *stream != '"' ) { //"
        var val: char = *stream;
        if (val == '\n') {
            error("String literal cannot contain newline\n");
            break;
        } else if (val == '\\') {
            stream += 1;
            if (*stream == 'x') {
                //  TODO
                // val = scan_hex_escape();
            } else {
                val = escapeToChar[(*stream) as (i32)];
                if (val == 0 && *stream != '0') {
                    error("Invalid string literal escape '\\%c'\n", *stream);
                }
                stream += 1;
            }
        } else {
            stream += 1;
        }
     
        buffer.append("%c", val)
    }
    if (*stream) {
        stream += 1;
    } else {
        error("Unexpected end of file within string literal\n");
    }

    token.kind = TokenKind.STRING;
    token.strValue = mem::memduplicate(buffer.cStr() as (void const*), buffer.size() + 1, alloc) as (char const*);
}


func (p: using Parser*) nextToken() {    

repeat:
    token.start = stream
    switch(*stream) {
        case ' ': 
        case '\n': 
        case '\r': 
        case '\t': {
      //  case '\v':
            while (isspace(*stream)) {
                if (*stream == '\n') {
                    lineStart = stream;
                    token.pos.line += 1;                    
                }
                stream += 1
            }
            goto repeat;        
        }
        case '"': { //"
            p.scanStr();
            break;
        }
        case '.':
            if (isdigit(stream[1])) {
                p.scanFloat();
            } 
            break;
        case '0': 
        case '1': 
        case '2': 
        case '3': 
        case '4': 
        case '5': 
        case '6': 
        case '7': 
        case '8': 
        case '9': {
            while (isdigit(*stream)) {
                stream += 1;
            }
            var c: char = *stream;
            stream = token.start;
            if (c == '.' || tolower(c) == 'e') {
                p.scanFloat();
            } else {
                p.scanInt();
            }
            break;
        }   
        case 'n': {
            if(stream[1] == 'u' && stream[2] == 'l' && stream[3] == 'l') {                
                stream += 4;
                token.kind = TokenKind.NULL
                break;
            }
            token.kind = TokenKind.ERROR
            break;
        }
        case 't': {
            if(stream[1] == 'r' && stream[2] == 'u' && stream[3] == 'e') {
                stream += 4;
                token.kind = TokenKind.TRUE
                break;
            }
            token.kind = TokenKind.ERROR
            break;
        }
        case 'f': {
            if(stream[1] == 'a' && stream[2] == 'l' && stream[3] == 's' && stream[4] == 'e') {                
                stream += 5;
                token.kind = TokenKind.FALSE
                break;
            }
            token.kind = TokenKind.ERROR
            break;
        }
        case '\0':
            token.kind = TokenKind.EOF
            stream += 1;
            break;
        case '{':
            token.kind = TokenKind.LEFT_BRACE
            stream += 1;
            break;
        case '}':
            token.kind = TokenKind.RIGHT_BRACE
            stream += 1;
            break;
        case '[':
            token.kind = TokenKind.LEFT_BRACKET
            stream += 1;            
            break;      
        case ']':
            token.kind = TokenKind.RIGHT_BRACKET
            stream += 1;
            break;
        case ',':
            token.kind = TokenKind.COMMA
            stream += 1;
            break;              
        case ':':
            token.kind = TokenKind.COLON
            stream += 1;
            break;
        default:
            error("Invalid '%c' token, skipping\n", *stream);
            stream += 1;
            token.kind = TokenKind.ERROR
            //goto repeat;
            break;
        }
        token.end = stream;
}

func (p: Parser*) check(kind: TokenKind) : bool {
    return p.token.kind == kind
}

func (p: Parser*) match(kind: TokenKind) : bool {
    if(!p.check(kind)) {
        return false
    }

    p.nextToken()
    return true    
}

func (p: Parser*) expect(kind: TokenKind) : bool {
    if(!p.check(kind)) {
        fatalError("Expected token %s, got %s\n", TokenName(kind), TokenName(p.token.kind));
        return false
    }

    p.nextToken()
    return true    
}



import "mem" as mem;
import "assert";
import "string_buffer";
import "map";
import "array";
import "libc";

@asStr
public enum JsonType {
    NULL,
    BOOLEAN,
    NUMBER,
    STRING,
    OBJECT,
    ARRAY,
}

public typedef Array<*JsonNode> as JsonArray;
public typedef Map<*const char, *JsonNode> JsonObject;

public union JsonValue {
    boolValue: bool
    doubleValue: f64
    strValue: *const char

    objValue: *JsonObject
    arrayValue: *JsonArray
}

public struct JsonNode {
    alloc: *const mem::Allocator
    type: JsonType
    value: using JsonValue
}

@inline
public func (node: *JsonNode) isNull() : bool {
    return node.type == JsonType.NULL
}

@inline
public func (node: *JsonNode) isBool() : bool {
    return node.type == JsonType.BOOLEAN
}

@inline
public func (node: *JsonNode) isTrue() : bool {
    return node.type == JsonType.BOOLEAN && node.value.boolValue
}

@inline
public func (node: *JsonNode) isFalse() : bool {
    return !node.isTrue()
}

@inline
public func (node: *JsonNode) isNumber() : bool {
    return node.type == JsonType.NUMBER
}
@inline
public func (node: *JsonNode) isString() : bool {
    return node.type == JsonType.STRING
}

@inline
public func (node: *JsonNode) isArray() : bool {
    return node.type == JsonType.ARRAY
}

@inline
public func (node: *JsonNode) isObject() : bool {
    return node.type == JsonType.OBJECT
}

@inline
public func (node: *JsonNode) asString() : *const char {
    return node.value.strValue
}

@inline
public func (node: *JsonNode) asBool() : bool {
    return node.value.boolValue
}

@inline
public func (node: *JsonNode) asNumber() : f64 {
    return node.value.doubleValue
}

@inline
public func (node: *JsonNode) asFloat() : f64 {
    return node.value.doubleValue
}

@inline
public func (node: *JsonNode) asInt() : i32 {
    return node.value.doubleValue as (i32)
}

@inline
public func (node: *JsonNode) asLong() : i64 {
    return node.value.doubleValue as (i64)
}

@inline
public func (node: *JsonNode) asArray() : *JsonArray {
    return node.value.arrayValue
}

@inline
public func (node: *JsonNode) asObject() : *JsonObject {
    return node.value.objValue
}

public func CreateJsonNumber(value: f64, alloc: *const mem::Allocator = mem::defaultAllocator) : *JsonNode {
    var node = mem::new<JsonNode>(alloc)
    node.alloc = alloc
    node.type = JsonType.NUMBER
    node.value = JsonValue {
        .doubleValue = value
    }

    return node
}


/**
    Duplicates the supplied string, and JsonNode manages the memory.  The supplied str will NOT be managed (i.e., free'd) upon
    JsonNode.free().
*/
public func CreateJsonString(str: *const char, len: i32 = -1,
                             alloc: *const mem::Allocator = mem::defaultAllocator) : *JsonNode {
    if(len < 0) {
        len = strlen(str);
    }

    var copy = mem::memduplicate(str as (*const void), (len + 1) * sizeof(:char), alloc) as (*char)
    copy[len] = '\0'

    return CreateJsonStringNoDup(copy, alloc)
}

/**
    The JsonNode will own the memory of str and deallocate it upon JsonNode.free()
    call
*/
public func CreateJsonStringNoDup(str: *const char,
                                  alloc: *const mem::Allocator = mem::defaultAllocator) : *JsonNode {
    var node = mem::new<JsonNode>(alloc)
    node.alloc = alloc
    node.type = JsonType.STRING
    node.value = JsonValue {
        .strValue = str
    }

    return node
}

public func CreateJsonArray(alloc: *const mem::Allocator = mem::defaultAllocator) : *JsonNode {
    var node = mem::new<JsonNode>(alloc)
    node.alloc = alloc
    node.type = JsonType.ARRAY
    node.value = JsonValue {
        .arrayValue = mem::new<JsonArray>(alloc)
    }

    node.value.arrayValue.init(16, alloc)

    return node
}

public func CreateJsonObject(alloc: *const mem::Allocator = mem::defaultAllocator) : *JsonNode {
    var node = mem::new<JsonNode>(alloc)
    node.alloc = alloc
    node.type = JsonType.OBJECT
    node.value = JsonValue {
        .objValue = mem::new<JsonObject>(alloc)
    }

    node.value.objValue.init(null, 16, &StrHashFn, &StrEqualFn, alloc)

    return node
}

public func (node: *JsonNode) put(key: *const char, n: *JsonNode, len: i32 = -1) {
    if(node.type != JsonType.OBJECT) {
        return;
    }

    if(len < 0) {
        len = strlen(key);
    }

    var copy = mem::memduplicate(key as (*const void), len + 1, node.alloc) as (*char)
    copy[len] = '\0'

    node.objValue.put(copy, n)
}


public func (node: *JsonNode) contains(key: *const char) : bool {
    if(node.type != JsonType.OBJECT) {
        return false;
    }

    return node.objValue.contains(key)
}

public func (node: *JsonNode) get(key: *const char) : *JsonNode {
    if(node.type != JsonType.OBJECT) {
        return null;
    }

    return node.objValue.get(key)
}

public func (node: *JsonNode) getBool(key: *const char, defaultValue: bool = false) : bool {
    var n = node.get(key)
    if(!n || !n.isBool()) {
        return defaultValue
    }

    return n.boolValue
}

public func (node: *JsonNode) getInt(key: *const char, defaultValue: i32 = 0) : i32 {
    var n = node.get(key)
    if(!n || !n.isNumber()) {
        return defaultValue
    }

    return n.doubleValue as (i32)
}

public func (node: *JsonNode) getLong(key: *const char, defaultValue: i64 = 0) : i64 {
    var n = node.get(key)
    if(!n || !n.isNumber()) {
        return defaultValue
    }

    return n.doubleValue as (i64)
}

public func (node: *JsonNode) getFloat(key: *const char, defaultValue: f64 = 0) : f64 {
    var n = node.get(key)
    if(!n || !n.isNumber()) {
        return defaultValue
    }

    return n.doubleValue
}

public func (node: *JsonNode) getStr(key: *const char, defaultValue: *const char = null) : *const char {
    var n = node.get(key)
    if(!n || !n.isString()) {
        return defaultValue
    }

    return n.strValue
}

public func (node: *JsonNode) getStrCopy(key: *const char, str: *char, len: i32) : *char {
    var n = node.get(key)
    if(!n || !n.isString()) {
        return str;
    }

    var srcLen = strlen(n.strValue)
    strncpy(str, n.strValue, MIN(srcLen, len));

    return str;
}

public func (node: *JsonNode) getArray(key: *const char) : *JsonNode {
    var n = node.get(key)
    if(!n || !n.isArray()) {
        return null
    }

    return n
}

public func (node: *JsonNode) getObject(key: *const char) : *JsonNode {
    var n = node.get(key)
    if(!n || !n.isObject()) {
        return null
    }

    return n
}

public func (node: *JsonNode) add(n: *JsonNode) {
    if(node.type == JsonType.ARRAY) {
        node.arrayValue.add(n)
    }
}

public func (node: *JsonNode) at(index: i32) : *JsonNode {
    if(node.type != JsonType.ARRAY) {
        return null;
    }

    return node.arrayValue.get(index)
}

public func (node: *JsonNode) size() : i32 {
    if(node.type == JsonType.ARRAY) {
        return node.arrayValue.size()
    }
    else if(node.type == JsonType.OBJECT) {
        return node.objValue.size()
    }

    return 0
}


public func (node: *JsonNode) print(buf: *StringBuffer) : *const char {
    PrintJson(node, buf)
    return buf.cStr()
}

public func (node: *JsonNode) free() {
    if(!node) {
        return;
    }

    var alloc = node.alloc

    // null,true,false don't have an allocator, we don't want to deallocate them
    // as they are globals
    if(!alloc) {
        return;
    }

    switch(node.type) {
        case JsonType.ARRAY: {
            for(var i = 0; i < node.arrayValue.size(); i+=1) {
                var n = node.arrayValue.get(i)
                if(n) {
                    n.free()
                }
            }

            node.arrayValue.free()
            alloc.free(node.arrayValue as (*void))
            break;
        }
        case JsonType.OBJECT: {
            var it = node.objValue.iter()
            while(it.hasNext()) {
                var entry = it.next()
                var key = entry.key
                alloc.free(key as (*void))

                var n = entry.value
                if(n) {
                    n.free()
                }
            }
            node.objValue.free()
            alloc.free(node.objValue as (*void))
            break;
        }
        case JsonType.STRING: {
            alloc.free(node.strValue as (*void))
            break;
        }
        default:
    }

    alloc.free(node as (*void))
}



public const JSON_NULL = &JsonNode {
    .alloc: null,
    .type: JsonType.NULL,
    .value: JsonValue {0},
}

public const JSON_TRUE = &JsonNode {
    .alloc: null,
    .type: JsonType.BOOLEAN,
    .value: JsonValue {.boolValue = true},
}

public const JSON_FALSE = &JsonNode {
    .alloc: null,
    .type: JsonType.BOOLEAN,
    .value: JsonValue {.boolValue = false},
}


enum TokenKind {
    EOF,
    ERROR,
    COMMA,
    COLON,
    LEFT_BRACE,
    RIGHT_BRACE,
    LEFT_BRACKET,
    RIGHT_BRACKET,
    NULL,
    NUMBER,
    TRUE,
    FALSE,
    STRING,
}

const tokenKindNames = []*const char {
    [TokenKind.EOF] = "EOF",
    [TokenKind.ERROR] = "ERROR",
    [TokenKind.COMMA] = ",",
    [TokenKind.COLON] = ":",
    [TokenKind.LEFT_BRACE] = "{",
    [TokenKind.RIGHT_BRACE] = "}",
    [TokenKind.LEFT_BRACKET] = "[",
    [TokenKind.RIGHT_BRACKET] = "]",
    [TokenKind.NULL] = "null",
    [TokenKind.NUMBER] = "number",
    [TokenKind.TRUE] = "true",
    [TokenKind.FALSE] = "false",
    [TokenKind.STRING] = "string",
}


const charToDigit = [256]i32 {
    ['0'] = 0,
    ['1'] = 1,
    ['2'] = 2,
    ['3'] = 3,
    ['4'] = 4,
    ['5'] = 5,
    ['6'] = 6,
    ['7'] = 7,
    ['8'] = 8,
    ['9'] = 9,
    ['a'] = 10, ['A'] = 10,
    ['b'] = 11, ['B'] = 11,
    ['c'] = 12, ['C'] = 12,
    ['d'] = 13, ['D'] = 13,
    ['e'] = 14, ['E'] = 14,
    ['f'] = 15, ['F'] = 15,
};

const escapeToChar = [256]char {
    ['0'] = '\0',
    ['\''] = '\'',
    ['"'] = '"',  // "
    ['\\'] = '\\',
    ['n'] = '\n',
    ['r'] = '\r',
    ['t'] = '\t',
    ['/'] = '/',
    //['v'] = '\v',
  //  ['b'] = '\b',
  //  ['a'] = '\a',
};


struct SrcPos {
    name: *const char
    line: i32
}

struct Token {
    kind: TokenKind
    pos: SrcPos
    start: *const char
    end: *const char

    union {
        numValue: f64
        strValue: *const char
        name: *const char
    }
}

public enum ParserStatus {
    OK = 0,
    WARNING,
    ERROR,
}

const MAX_MESSAGE_SIZE = 256

public struct Parser {
    alloc: *const mem::Allocator
    status: ParserStatus
    errorMsg: [MAX_MESSAGE_SIZE]char

    token: Token
    buffer: StringBuffer
    stream: *const char
    lineStart: *const char
}

public func (p: *Parser) init(alloc: *const mem::Allocator = mem::defaultAllocator) {
    p.alloc = alloc
    p.status = ParserStatus.OK
    mem::memset(p.errorMsg, 0, MAX_MESSAGE_SIZE)

    p.stream = null
    p.lineStart = null
    p.token.pos.name = "<string>";
    p.token.pos.line = 1
    p.buffer.init(16, alloc)
}

public func (p: *Parser) free() {
    p.buffer.free()
    p.stream = null
    p.lineStart = null
}

public func (p: *Parser) parseJson(buffer: *const char) : *JsonNode {
    p.stream = buffer
    p.lineStart = p.stream

    p.buffer.clear()
    p.nextToken()

    var node = p.parseJsonNode()
    if(p.hasError()) {
        if(node) {
            node.free()
        }
        return null;
    }

    return node
}

public func (p: *Parser) hasError() : bool {
    return p.status == ParserStatus.ERROR
}

public func PrintJson(node: *JsonNode, buf: *StringBuffer) {
    if(!node) {
        return;
    }
    switch(node.type) {
        case JsonType.NULL: {
            buf.append("null")
            break;
        }
        case JsonType.BOOLEAN: {
            (node.boolValue) ?
                buf.append("true") : buf.append("false")
            break;
        }
        case JsonType.NUMBER: {
            buf.append("%f", node.doubleValue)
            break;
        }
        case JsonType.STRING: {
            buf.append("\"%s\"", node.strValue)
            break;
        }
        case JsonType.OBJECT: {
            buf.append("{")
            var obj = node.objValue

            var isFirst = true
            var it = obj.iter()
            while(it.hasNext()) {
                var entry = it.next()

                if(!isFirst) buf.append(",")
                buf.append("\"%s\":", entry.key)
                PrintJson(entry.value, buf)
                isFirst = false
            }
            buf.append("}")
            break;
        }
        case JsonType.ARRAY: {
            buf.append("[")
            var array = node.arrayValue
            var isFirst = true
            for(var i = 0; i < array.size(); i+=1) {
                if(!isFirst) buf.append(",")
                PrintJson(array.get(i), buf)
                isFirst = false
            }
            buf.append("]")
            break;
        }
    }
}



func (p: *Parser) parseJsonNode() : *JsonNode {
    if(p.hasError()) {
        return null;
    }

    switch(p.token.kind) {
        case TokenKind.EOF:
        case TokenKind.ERROR:
            return null;
        case TokenKind.TRUE:
            p.nextToken()
            return JSON_TRUE
        case TokenKind.FALSE:
            p.nextToken()
            return JSON_FALSE
        case TokenKind.NULL:
            p.nextToken()
            return JSON_NULL
        case TokenKind.NUMBER:
            p.nextToken()
            return p.parseJsonNumber()
        case TokenKind.STRING:
            p.nextToken()
            return p.parseJsonStr()
        case TokenKind.LEFT_BRACE:
            p.nextToken()
            return p.parseJsonObject()
        case TokenKind.LEFT_BRACKET:
            p.nextToken()
            return p.parseJsonArray()
        default:
    }

    return null
}

func (p: using *Parser) parseJsonNumber() : *JsonNode {
    return CreateJsonNumber(token.numValue, p.alloc)
}

func (p: using *Parser) parseJsonStr() : *JsonNode {
    return CreateJsonStringNoDup(token.strValue, p.alloc)
}

func (p: using *Parser) parseJsonArray() : *JsonNode {
    var node = CreateJsonArray(p.alloc)

    do {
        if(p.check(TokenKind.RIGHT_BRACKET)) {
            break;
        }
        var element = p.parseJsonNode();
        node.value.arrayValue.add(element)
    }
    while (p.match(TokenKind.COMMA));

    p.expect(TokenKind.RIGHT_BRACKET)
    return node
}
func (p: using *Parser) parseJsonObject() : *JsonNode {
    var node = CreateJsonObject(p.alloc)

    do {
        if(p.check(TokenKind.RIGHT_BRACE)) {
            break;
        }

        var key = p.token.strValue
        if(!p.expect(TokenKind.STRING)) {
            goto err
        }

        if(!p.expect(TokenKind.COLON)) {
            goto err
        }

        var value = p.parseJsonNode();
        node.value.objValue.put(key, value)
    }
    while (p.match(TokenKind.COMMA));

    p.expect(TokenKind.RIGHT_BRACE)
err:
    return node
}

func TokenName(t: TokenKind) : *const char {
    return tokenKindNames[t]
}


func (p: *Parser) error(format: *const char, ...) {
    var args: va_list;
    va_start(args, format);

    vsnprintf(p.errorMsg, MAX_MESSAGE_SIZE, format, args);
    va_end(args);

    p.status = ParserStatus.ERROR
    p.token.kind = TokenKind.ERROR
}

func (p: using *Parser) scanInt() {
    var base = 10;
    var start_digits = stream;
    if (*stream == '0') {
        stream += 1;
        if (tolower(*stream) == 'x') {
            stream += 1;
            base = 16;
            start_digits = stream;
        } else if (tolower(*stream) == 'b') {
            stream += 1;
            base = 2;
            start_digits = stream;
        } else if (isdigit(*stream)) {
            base = 8;
            start_digits = stream;
        }
    }
    var val: i64 = 0;
    for (;;) {
        if (*stream == '_') {
            stream += 1;
            continue;
        }
        var digit = charToDigit[(*stream) as (i32)];
        if (digit == 0 && *stream != '0') {
            break;
        }
        if (digit >= base) {
            p.error("Digit '%c' out of range for base %d", *stream, base);
            digit = 0;
        }
        if (val > (ULLONG_MAX - digit)/base) {
            p.error("Integer literal overflow");
            while (isdigit(*stream)) {
                stream += 1;
            }
            val = 0;
            break;
        }
        val = val*base + digit;
        stream += 1;
    }
    if (stream == start_digits) {
        p.error("Expected base %d digit, got '%c'", base, *stream);
    }

    if(p.hasError()) {
        return;
    }

    token.kind = TokenKind.NUMBER; //TOKEN_INT;
    token.numValue = val;
}

func (p: using *Parser) scanFloat() {
    var start = p.stream;

    while (isdigit(*stream)) {
        stream+=1;
    }
    if (*stream == '.') {
        stream+=1;
    }
    while (isdigit(*stream)) {
        stream+=1;
    }
    if (tolower(*stream) == 'e') {
        stream+=1;
        if (*stream == '+' || *stream == '-') {
            stream+=1;
        }
        if (!isdigit(*stream)) {
            p.error("Expected digit after float literal exponent, found '%c'.", *stream);
        }
        while (isdigit(*stream)) {
            stream+=1;
        }
    }
    var val = strtod(start, null);
    if (val == HUGE_VAL) {
        p.error("Float literal overflow");
    }

    if(p.hasError()) {
        return;
    }

    token.kind = TokenKind.NUMBER;
    token.numValue = val;
}

func (p: using *Parser) scanStr() {
    assert(*stream == '"'); // "
    stream+=1;
    buffer.clear()

    while (*stream && *stream != '"' ) { //"
        var val: char = *stream;
        if (val == '\n') {
            p.error("String literal cannot contain newline");
            break;
        } else if (val == '\\') {
            stream += 1;
            if (*stream == 'x') {
                //  TODO
                // val = scan_hex_escape();
            } else {
                val = escapeToChar[(*stream) as (i32)];
                if (val == 0 && *stream != '0') {
                    p.error("Invalid string literal escape '\\%c'", *stream);
                }
                stream += 1;
            }
        } else {
            stream += 1;
        }

        buffer.append("%c", val)
    }
    if (*stream) {
        stream += 1;
    } else {
        p.error("Unexpected end of file within string literal");
    }

    if(p.hasError()) {
        return;
    }

    token.kind = TokenKind.STRING;
    token.strValue = mem::memduplicate(buffer.cStr() as (*const void), buffer.size() + 1, alloc) as (*const char);
}

func (p: using *Parser) scanMultiStr() {
    assert(*stream == '`'); // "
    stream+=1;
    buffer.clear()

    while (*stream && *stream != '`' ) {
        var val: char = *stream;
        if (val == '\\') {
            stream += 1;
            if(*stream == '`') {
                val = '`'
                stream += 1
            } else {
                buffer.append("%c", val)
                val = *stream
                stream += 1;
            }
        } else {
            stream += 1;
        }

        buffer.append("%c", val)
    }
    if (*stream) {
        stream += 1;
    } else {
        p.error("Unexpected end of file within string literal");
    }

    if(p.hasError()) {
        return;
    }

    token.kind = TokenKind.STRING;
    token.strValue = mem::memduplicate(buffer.cStr() as (*const void), buffer.size() + 1, alloc) as (*const char);
}

func (l: *Parser) skipComments() {
    if(*l.stream == '/') {
        if(l.stream[1] == '/') {
            l.stream += 1
            do {
                l.stream += 1
                if(*l.stream == '\n') {
                    break;
                }
            }
            while(l.stream)
        }
        else if(l.stream[1] == '*') {
            l.stream += 1 // eat /
            do {
                l.stream += 1
                if((l.stream[0] == '*' && l.stream[1] == '/')) {
                    l.stream += 2
                    break;
                }
            }
            while(l.stream)
        }
    }
}


func (p: using *Parser) nextToken() {

repeat:
    if(p.hasError()) {
        return;
    }

    p.skipComments()

    token.start = stream
    switch(*stream) {
        case ' ':
        case '\n':
        case '\r':
        case '\t': {
      //  case '\v':
            while (isspace(*stream)) {
                if (*stream == '\n') {
                    lineStart = stream;
                    token.pos.line += 1;
                }
                stream += 1
            }
            goto repeat;
        }
        case '"': { //"
            p.scanStr();
            break;
        }
        case '`': {
            p.scanMultiStr()
            break;
        }
        case '.':
            if (isdigit(stream[1])) {
                p.scanFloat();
            }
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9': {
            while (isdigit(*stream)) {
                stream += 1;
            }
            var c: char = *stream;
            stream = token.start;
            if (c == '.' || tolower(c) == 'e') {
                p.scanFloat();
            } else {
                p.scanInt();
            }
            break;
        }
        case 'n': {
            if(stream[1] == 'u' && stream[2] == 'l' && stream[3] == 'l') {
                stream += 4;
                token.kind = TokenKind.NULL
                break;
            }
            p.error("invalid identifier, did you mean 'null'?")
            break;
        }
        case 't': {
            if(stream[1] == 'r' && stream[2] == 'u' && stream[3] == 'e') {
                stream += 4;
                token.kind = TokenKind.TRUE
                break;
            }
            p.error("invalid identifier, did you mean 'true'?")
            break;
        }
        case 'f': {
            if(stream[1] == 'a' && stream[2] == 'l' && stream[3] == 's' && stream[4] == 'e') {
                stream += 5;
                token.kind = TokenKind.FALSE
                break;
            }
            p.error("invalid identifier, did you mean 'false'?")
            break;
        }
        case '\0':
            token.kind = TokenKind.EOF
            stream += 1;
            break;
        case '{':
            token.kind = TokenKind.LEFT_BRACE
            stream += 1;
            break;
        case '}':
            token.kind = TokenKind.RIGHT_BRACE
            stream += 1;
            break;
        case '[':
            token.kind = TokenKind.LEFT_BRACKET
            stream += 1;
            break;
        case ']':
            token.kind = TokenKind.RIGHT_BRACKET
            stream += 1;
            break;
        case ',':
            token.kind = TokenKind.COMMA
            stream += 1;
            break;
        case ':':
            token.kind = TokenKind.COLON
            stream += 1;
            break;
        default:
            p.error("Invalid '%c' token", *stream);
            stream += 1;
            token.kind = TokenKind.ERROR
            break;
        }
        token.end = stream;
}

func (p: *Parser) check(kind: TokenKind) : bool {
    return p.token.kind == kind
}

func (p: *Parser) match(kind: TokenKind) : bool {
    if(!p.check(kind)) {
        return false
    }

    p.nextToken()
    return true
}

func (p: *Parser) expect(kind: TokenKind) : bool {
    if(!p.check(kind)) {
        if(p.hasError()) {
            return false
        }

        p.error("Expected token %s, got %s", TokenName(kind), TokenName(p.token.kind));
        return false
    }

    p.nextToken()
    return true
}



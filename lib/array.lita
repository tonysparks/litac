import "mem" as mem;
import "assert"

/*
    Simple dynamically expandle array
*/    
public struct Array<T> {
    length: i32
    capacity: i32
    elements: T*
    alloc: mem::Allocator const*
}

public func (a: Array<T>*) init<T>(initialSize: i32 = 16, alloc: mem::Allocator const* = mem::cAllocator) {    
    a.alloc = alloc;
    a.length = 0;
    a.capacity = initialSize;    
    
    var length = (sizeof(T) * initialSize as (u64));    
    a.elements = alloc.alloc(length) as (T*)
}

public func (a: Array<T>*) free<T>() {
    if(a && a.elements) {
        a.alloc.free(a.elements as (void*))
        a.elements = null
        a.length = 0
        a.capacity = 0
    }
}

public func (a: Array<T>*) add<T>(element: T) {
    if(a.length + 1 > a.capacity) {
        ArrayGrow<T>(a, 1)        
    }
    a.elements[a.length] = element;
    a.length += 1
}

public func (a: Array<T>*) push<T>(element: T) {
    a.add<T>(a, element)
}

public func (a: Array<T>*) get<T>(index: i32) : T {
    assert(index >= 0 && index < a.length)

    return a.elements[index]
}

public func (a: Array<T>*) set<T>(index: i32, element: T) {
    assert(index >= 0 && index < a.length)

    a.elements[index] = element;
}

public func (a: Array<T>*) first<T>() : T {    
    assert(a.length != 0)
    
    return a.elements[0]
}

public func (a: Array<T>*) last<T>() : T {    
    assert(a.length != 0)
    
    return a.elements[a.length - 1]
}

public func (a: Array<T>*) pop<T>() : T {
    assert(a.length != 0)
    
    var r = a.elements[a.length - 1]
    a.length -= 1
    
    return r
}

public func (a: Array<T>*) removeAt<T>(index: i32) : T {
    assert(index >= 0 && index < a.length)
    
    var r = a.elements[index]
    if(index < a.length - 1) {
        mem::memmove((&a.elements[index]) as (void*), 
                     (&a.elements[index + 1]) as (void const*), 
                     ((a.length - 1) - index) * sizeof(T))
    }
    
    a.length -= 1
    return r
}


public func (a: Array<T>*) addAll<T>(other: Array<T>*) {
    if(!other && other.length > 0) {
        return;
    }
    
    if(a.length + other.length > a.capacity) {
        ArrayGrow<T>(a, other.length)
    }
    
    mem::memcpy((&a.elements[a.length]) as (void*), 
                (&other.elements[0]) as (void const*), 
                other.length * sizeof(T))
    a.length += other.length
}

public func (a: Array<T>*) forEach<T>(fn : func<T>(T) : bool) {
    for(var i = 0; i < a.length; i+=1) {
        if(fn<T>(a.elements[i])) {
            break;
        }
    }
}

public func (a: Array<T>*) empty<T>() : bool {
    return a.length == 0
}

public func (a: Array<T>*) size<T>() : i32 {
    return a.length
}

func ArrayGrow<T>(a: Array<T>*, increment: i32) {
    var doubleCurrent = a.capacity * 2
    var minReq = a.length + increment
    var n = minReq
    
    if(doubleCurrent > minReq) {
        n = doubleCurrent        
    }
    
    var newlength = (sizeof(T) * n as (u64));     
    var oldlength = (sizeof(T) * a.capacity as(u64));
    a.elements = a.alloc.realloc(a.elements as (void*), oldlength, newlength) as (T*)
    a.capacity = n;    
}
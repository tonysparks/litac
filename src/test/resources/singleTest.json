{
    description: "Single Test",
    disabled: false,
    debug: true,
    program: '''                
        @include("assert.h");
        @foreign func assert(e:bool):void;
        
        %definitions%
        
        func main(len:i32, args:char**):i32 {
            %test%
        }
    '''
    tests: [                           
        /*
        { 
            name: "Str assigned to array",
            definitions: '''
                @include("<string.h>");
                @foreign func strcmp(a:char const*, b:char const*) : i32;
                                                
                struct Test {
                    name: [32]char
                }
            ''',                       
            code: '''         
                var t = Test{
                    .name = "Brett"
                }                 
                           
                assert(strcmp(t.name, "Brett") == 0)
            ''',                      
        },
        { 
            name: "array assigned to str",
            definitions: '''
                @include("<string.h>");
                @foreign func strcmp(a:char const*, b:char const*) : i32;
                                                
                struct Test {
                    name: char*
                    x: [32]char                    
                }
                
                struct X {
                    x: [32]char
                }
            ''',                       
            code: '''        
                var m : [32]char = "Brett"
                var x = X{m}  
                var t = Test{
                    .name = m,
                    .x = x.x
                    
                }                 
                           
                assert(strcmp(t.name, "Brett") == 0)
            ''',                      
        },
        { 
            name: "Const char index to char",
            definitions: '''
                @include("<string.h>");
                @foreign func strcmp(a:char const*, b:char const*) : i32;
                                                
                struct Test {
                    name: char const*
                                   
                }                
            ''',                       
            code: '''        
                var t = Test{"Brett"}                
                var x = *t.name                 
                           
                assert(x == 'B')
            ''',                      
        },
        */
        /*
        { 
            name: "Anon Union",
            definitions: '''
                @include("<string.h>");
                @foreign func strcmp(a:char const*, b:char const*) : i32;
                         
                struct X {
                    a: i32
                }
                
                func (x: X*) method() : i32 {
                    return x.a
                }
                                                
                struct Test {
                    union {
                        w: X*
                        y: X*
                    }                                   
                }                
            ''',                       
            code: '''        
                var x = X{4}
                var t = Test {.w = &x}
                var w = t.w
                assert(w.method() == 4)
            ''',                      
        },*/
        /*{ 
            name: "Arena Allocator",
            definitions: '''
                import "mem";
                import "array";
                import "io";           
                import "map";
                import "json";
                import "string_buffer"
                
            ''',                       
            code: '''        
                debugAllocator.init()
                defer { 
                    debugAllocator.report(); 
                    debugAllocator.free(); 
                }
                
                var arena = Arena{}
                arena.init(4096, &debugAllocator.alloc)
                defer {
                    arena.free()                    
                    assert(debugAllocator.allocations.empty())
                }
                
                var array = Array<i32>{}
                array.init(2, &arena.alloc)
                
                const size = 1024
                for(var i = 0; i < size; i+=1) {
                    array.add(i)
                }
                
                assert(array.size() == size)
                
                var map = Map<char const*, i32>{}
                map.init(0, 1, &StrHashFn, &StrEqualFn, &arena.alloc)
                
                map.put("hi1", 421)
                map.put("hi2", 422)
                map.put("hi3", 423)
                map.put("hi4", 424)
                map.put("hi5", 425)
                
                assert(map.size() == 5)
                
                var parser = Parser{}
                parser.init(&arena.alloc)
                
                var node = parser.parseJson("""
                    {
                        "x" : true,
                        "y" : false,
                        "z" : [1,2,3]
                    }
                """);
                
                var buf = StringBuffer{}
                buf.init(1, &arena.alloc)
                node.print(&buf)
                
                printf("%s\n", buf.cStr())
                
            ''',                      
        },*/    
        /*   
        { 
            name: "Arena Allocator with Default",
            definitions: '''
                import "mem";
                import "array";
                import "io";           
                import "map";
                import "json";
                import "string_buffer"
                
            ''',                       
            code: '''        
                debugAllocator.init(cAllocator)
                defer { 
                    debugAllocator.report(); 
                    debugAllocator.free(); 
                }
                
                var arena = Arena{}
                arena.init(4096, &debugAllocator.alloc)
                defer {
                    arena.free()                    
                    assert(debugAllocator.allocations.empty())
                }
                
                defaultAllocator = (&arena.alloc) as (Allocator const*)
                
                var array = Array<i32>{}
                array.init(2)
                
                const size = 1024
                for(var i = 0; i < size; i+=1) {
                    array.add(i)
                }
                
                assert(array.size() == size)
                
                var map = Map<char const*, i32>{}
                map.init(0, 1, &StrHashFn, &StrEqualFn)
                
                map.put("hi1", 421)
                map.put("hi2", 422)
                map.put("hi3", 423)
                map.put("hi4", 424)
                map.put("hi5", 425)
                
                assert(map.size() == 5)
                
                var parser = Parser{}
                parser.init()
                
                var node = parser.parseJson("""
                    {
                        "x" : true,
                        "y" : false,
                        "z" : [1,2,3]
                    }
                """);
                
                var buf = StringBuffer{}
                buf.init(1)
                node.print(&buf)
                
                printf("%s\n", buf.cStr())
                
            ''',                      
        },
        
        { 
            name: "Simple",
            definitions: '''
                import "array"
                struct X<T> {
                    i:T
                }
            ''',                       
            code: '''  
                var x = X{4}
                assert(x.i == 4)
            '''
        }*/
        
        /*{ 
            name: "Generics Type Inference from Struct of Struct Generic Type multiple",
            definitions: '''                
                struct B<Z> {
                    b: Z
                }
                struct Test<X, Y> {
                    t : B<X>
                    v : B<Y>
                }
                func test<T, V>(a:Test<T, V>):T {
                    return a.t.b
                }
            ''',                       
            code: '''         
                var t = Test<i32, char*> { B<i32>{4}, B<char*>{"hi"} }                                 
                assert(test(t) == 4)
            ''',                      
        },*/
        { 
            name: "Generics Partial",
            definitions: '''                
                struct Test<X, Y> {
                    x: X
                    y: Y
                }
                
                func test<Y>() : Test<i32, Y> {
                    var t = Test<i32, Y> {        
                    }
                    
                    return t
                }
            ''',                       
            code: '''         
                var t: Test<i32, f32> = test<f32>()
                t.x = 10_i32
                t.y = 22_f32
                                
                assert(t.x == 10_i32)
                assert(t.y == 22_f32)
            ''',                      
        },/*
        { 
            name: "Simple",
            definitions: '''
                                
                //struct Test {
                //    x: i32
                //}
                
                //var y = 24
                //const z = 66
                
                //var w = Test{.x = 4}
                
                //func (t: Test*) test(x: i32) : i32 {
                //    if(t.x > 0) {
                //        return -1
                //    }
                //    return t.x
                //}
                
                struct Test<V> {
                    x: V
                }
                
                func (t: Test<V>*) test<V>() : V {                    
                    return t.x
                }
            ''',                       
            code: '''         
                //w.test(24)
                var t = Test<i32> { .x = 4 }
                t.test<i32>()
            ''',                      
        }, */               
    ]
}
{
    description: "Single Test",
    disabled: false,
    debug: true,
    program: '''                
        @include("assert.h");
        @foreign func assert(e:bool):void;
        
        %definitions%
        
        func main(len:i32, args:char**):i32 {
            %test%
        }
    '''
    tests: [                           
        /*
        { 
            name: "Str assigned to array",
            definitions: '''
                @include("<string.h>");
                @foreign func strcmp(a:char const*, b:char const*) : i32;
                                                
                struct Test {
                    name: [32]char
                }
            ''',                       
            code: '''         
                var t = Test{
                    .name = "Brett"
                }                 
                           
                assert(strcmp(t.name, "Brett") == 0)
            ''',                      
        },
        { 
            name: "array assigned to str",
            definitions: '''
                @include("<string.h>");
                @foreign func strcmp(a:char const*, b:char const*) : i32;
                                                
                struct Test {
                    name: char*
                    x: [32]char                    
                }
                
                struct X {
                    x: [32]char
                }
            ''',                       
            code: '''        
                var m : [32]char = "Brett"
                var x = X{m}  
                var t = Test{
                    .name = m,
                    .x = x.x
                    
                }                 
                           
                assert(strcmp(t.name, "Brett") == 0)
            ''',                      
        },
        { 
            name: "Const char index to char",
            definitions: '''
                @include("<string.h>");
                @foreign func strcmp(a:char const*, b:char const*) : i32;
                                                
                struct Test {
                    name: char const*
                                   
                }                
            ''',                       
            code: '''        
                var t = Test{"Brett"}                
                var x = *t.name                 
                           
                assert(x == 'B')
            ''',                      
        },
        */
        /*
        { 
            name: "Anon Union",
            definitions: '''
                @include("<string.h>");
                @foreign func strcmp(a:char const*, b:char const*) : i32;
                         
                struct X {
                    a: i32
                }
                
                func (x: X*) method() : i32 {
                    return x.a
                }
                                                
                struct Test {
                    union {
                        w: X*
                        y: X*
                    }                                   
                }                
            ''',                       
            code: '''        
                var x = X{4}
                var t = Test {.w = &x}
                var w = t.w
                assert(w.method() == 4)
            ''',                      
        },*/
        /*{ 
            name: "Arena Allocator",
            definitions: '''
                import "mem";
                import "array";
                import "io";           
                import "map";
                import "json";
                import "string_buffer"
                
            ''',                       
            code: '''        
                debugAllocator.init()
                defer { 
                    debugAllocator.report(); 
                    debugAllocator.free(); 
                }
                
                var arena = Arena{}
                arena.init(4096, &debugAllocator.alloc)
                defer {
                    arena.free()                    
                    assert(debugAllocator.allocations.empty())
                }
                
                var array = Array<i32>{}
                array.init(2, &arena.alloc)
                
                const size = 1024
                for(var i = 0; i < size; i+=1) {
                    array.add(i)
                }
                
                assert(array.size() == size)
                
                var map = Map<char const*, i32>{}
                map.init(0, 1, &StrHashFn, &StrEqualFn, &arena.alloc)
                
                map.put("hi1", 421)
                map.put("hi2", 422)
                map.put("hi3", 423)
                map.put("hi4", 424)
                map.put("hi5", 425)
                
                assert(map.size() == 5)
                
                var parser = Parser{}
                parser.init(&arena.alloc)
                
                var node = parser.parseJson("""
                    {
                        "x" : true,
                        "y" : false,
                        "z" : [1,2,3]
                    }
                """);
                
                var buf = StringBuffer{}
                buf.init(1, &arena.alloc)
                node.print(&buf)
                
                printf("%s\n", buf.cStr())
                
            ''',                      
        },*/    
        /*   
        { 
            name: "Arena Allocator with Default",
            definitions: '''
                import "mem";
                import "array";
                import "io";           
                import "map";
                import "json";
                import "string_buffer"
                
            ''',                       
            code: '''        
                debugAllocator.init(cAllocator)
                defer { 
                    debugAllocator.report(); 
                    debugAllocator.free(); 
                }
                
                var arena = Arena{}
                arena.init(4096, &debugAllocator.alloc)
                defer {
                    arena.free()                    
                    assert(debugAllocator.allocations.empty())
                }
                
                defaultAllocator = (&arena.alloc) as (Allocator const*)
                
                var array = Array<i32>{}
                array.init(2)
                
                const size = 1024
                for(var i = 0; i < size; i+=1) {
                    array.add(i)
                }
                
                assert(array.size() == size)
                
                var map = Map<char const*, i32>{}
                map.init(0, 1, &StrHashFn, &StrEqualFn)
                
                map.put("hi1", 421)
                map.put("hi2", 422)
                map.put("hi3", 423)
                map.put("hi4", 424)
                map.put("hi5", 425)
                
                assert(map.size() == 5)
                
                var parser = Parser{}
                parser.init()
                
                var node = parser.parseJson("""
                    {
                        "x" : true,
                        "y" : false,
                        "z" : [1,2,3]
                    }
                """);
                
                var buf = StringBuffer{}
                buf.init(1)
                node.print(&buf)
                
                printf("%s\n", buf.cStr())
                
            ''',                      
        },
        
        { 
            name: "Simple",
            definitions: '''
                import "array"
                struct X<T> {
                    i:T
                }
            ''',                       
            code: '''  
                var x = X{4}
                assert(x.i == 4)
            '''
        }*/
        
        /*
        { 
            name: "Generics Type Inference from Struct of Struct Generic Type multiple",
            definitions: '''                
                struct B<Z> {
                    b: Z
                }
                struct Test<X, Y> {
                    t : B<X>
                    v : B<Y>
                }
                func test<T, V>(a:Test<T, V>):T {
                    return a.t.b
                }
            ''',                       
            code: '''         
                var t = Test<i32, char*> { B<i32>{4}, B<char*>{"hi"} }                                 
                assert(test<i32, char*>(t) == 4)
            ''',                      
        },
        
        
        { 
            name: "Generics Partial",
            definitions: '''                
                struct Test<X, Y> {
                    x: X
                    y: Y
                }
                
                func test<Y>() : Test<i32, Y> {
                    var t = Test<i32, Y> {        
                    }
                    
                    return t
                }
            ''',                       
            code: '''         
                var t: Test<i32, f32> = test<f32>()
                t.x = 10_i32
                t.y = 22_f32
                                
                assert(t.x == 10_i32)
                assert(t.y == 22_f32)
            ''',                      
        },
        
        
        { 
            name: "Simple",
            definitions: '''
           
                struct Child {
                    x: i32
                }
                                
                struct Parent {
                    c: Child
                }
                
            ''',                       
            code: '''         
                var p = Parent {.c = Child{4} }
                assert(p.c.x == 4)
            ''',                      
        },
        
        {
            name: "Foreign funcPtr",
            symbolPrefix: "litaC__",
            definitions: '''
                @raw("""
                // hand written
                typedef int (*SomeFunc)(int x);      
                
                int nativeFn(SomeFunc aFn) {
                   return aFn(4);
                }
                // end handwritten
                """);
                
                @foreign
                func nativeFn(aFn: SomeFunc) : i32;
                
                @foreign
                typedef func(i32) : i32 as SomeFunc;
                
                
                func test(x: i32) : i32 {
                    return x
                }
                
                func testFn(aFn: SomeFunc) : i32 {
                    return aFn(4)
                }
            ''',                       
            code: '''  
                var fn = &test
                
                assert(fn(4)== 4)
                assert(testFn(fn) == 4)
                assert(nativeFn(fn) == 4)
                    
            ''',
        },
        
        
        
        { 
            name: "Simple",
            definitions: '''
                import "moduleX" as x 
                //import "moduleY" 
                //import "mem"
                
                struct Y {
                    v: x::X
                }              
            ''',       
            modules: [
                {
                    name: "moduleX",
                    program: '''
                        import "moduleY"
                        
                        public struct X {
                            i: i32
                        }
                    '''
                },
                {
                    name: "moduleY",
                    program: '''
                        import "moduleX" as x
                        
                        public struct H {
                            i: x::X
                        }
                    '''
                }
            ]                
            code: '''  
                var x = x::X{4}
                var y = Y {.v = x}
                //var h = H {.i = x}
                assert(x.i == 4)
                assert(y.v.i == 4)
            '''
        },
        
        { 
            name: "Simple",
            definitions: '''
                //import "mem"
                
                
                func test<T>(t: T) : T {
                    return t
                }
                
                typedef func():i32 as Fn;
                
                func n() : i32 {
                    return 4
                }
                
                func curry<T>() : Fn {
                    return n
                }
                
                struct Test<T> {
                    x: T
                }
                
                func (t: Test<T>*) call<T>() : T {
                    return t.x
                }
                                  
            ''',                                   
            code: '''  
                assert(test(4) == 4)
                assert(curry<i32>()() == 4)
                var t = Test<i32> {.x = 4}
                assert(t.call() == 4)
            '''
        }*/
        
        /*
        { 
            name: "Generic Func Param in different module",
            definitions: '''
                import "moduleX" 
                import "moduleY"                                              
            ''',       
            modules: [
                {
                    name: "moduleX",
                    program: '''
                        
                        public struct X<T> {
                            x: T
                        }
                        
                        
                        public func test<T>(t: T) : i32 {
                            return t.x
                        }                        
                        
                    '''
                },
                {
                    name: "moduleY",
                    program: '''                                               
                        public struct Y<T> {
                            x: T
                        }
                    '''
                }
            ]                
            code: '''  
                var x = X<i32>{.x=4}
                var y = Y<i32>{.x=8}
                
                assert(test(x) == 4)
                assert(test(y) == 8)
            '''
        }
        
        { 
            name: "Init inferrence",
            definitions: '''
                struct X<T> {
                    x: T
                }                                         
            ''',                                  
            code: '''  
                var x = X{.x = 4}
                assert(x.x == 4)
            '''
        },
        */
        
        { 
            name: "Init inferrence",
            definitions: '''
                import "mem"
                import "clib" as c   
                                                         
            ''',                                  
            code: '''  
                
                var x = c::MAX(1,2)
                //var x: i32* = null
                //var m = defaultAllocator.alloc(24)
               // defer defaultAllocator.free(m)
            '''
        }                                                     
    ]
}
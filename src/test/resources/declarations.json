{
	description: "Tests Declarations",
	program: '''				
		@include("assert.h");
		@foreign func assert(e:bool):void;
		
		%definitions%
		
		func main(len:i32, args:char**):i32 {
			%test%
		}
	'''
	tests: [		
		/*{
			name: "Primatives",
			code: '''
				var i = 32
				assert( i == 32 )
				
				var j = 64_i64
				assert( j == 64_i64 )
				
				var b = false
				assert( !b )
				b = true
				assert(b)
				
				var f = 45.756
				assert(f == 45.756)
				
				var d = 245.756_f64
				assert(d == 245.756_f64)
				
				var p = "hello"				
				assert(p)
				assert(p[0] == 'h')
				
				var index = p
				var k = 0
				while (*index) {
					assert(p[k] == *index)
					index += 1
					k += 1
				}
				  
			'''
		}, 
		{
			name: "Casts",
			definitions: '''
				struct T {
					v: i32
				}
				
				struct X<T> {
					v: T
				}
							
			''',			
			code: '''
				var i : i64 = 32 as (i64) + 45_i64
				assert( i == 77_i64 )
				
				
				i = 2_i64*32 as (i64) + 45_i64
				assert( i == 109_i64 )

				
				var t = T { 4}
				var x = X<i32> {44} as (X<i32>)
				  
			'''
		}, 
		{
			name: "Invalid struct Casts",
			definitions: '''				
				struct X<T> {
					v: T
				}
							
			''',			
			code: '''
				var x = X<i32> {44} as (X<f32>)
				  
			''',
			error: "'struct Xf32' can't be casted to 'struct Xi32'"
		},
		{
			name: "Invalid union Casts",
			definitions: '''				
				union X<T> {
					v: T
				}
							
			''',			
			code: '''
				var x = X<i32> {44} as (X<f32>)
				  
			''',
			error: "'union Xf32' can't be casted to 'union Xi32'"
		},
		{
			name: "Generics struct with union",
			definitions: '''				
				struct Person<T> {
					union X<T> {
						v: T
					}
				}
							
			''',			
			code: '''
				var x = Person<i32> { .X: X<i32>{4} }				
				assert(x.X.v == 4)
				  
			'''
		},
		{
			name: "Generics struct within union and generic field",
			definitions: '''				
				struct Person<T> {
					union X<T> {
						v: T
					}
					age: T
				}
							
			''',			
			code: '''
				var x = Person<i32> { .X: X<i32>{4}, .age:56 }				
				assert(x.X.v == 4)
				assert(x.age == 56)  
			'''
		},
		{
			name: "Generics struct within union and field",
			definitions: '''				
				struct Person<T> {
					union X<T> {
						v: T
					}
					age: i64
				}
							
			''',			
			code: '''
				var x = Person<i32> { .X: X<i32>{4}, .age:56_i64 }				
				assert(x.X.v == 4)
				assert(x.age == 56_i64)  
			'''
		},
		{
			name: "Enum",
			definitions: '''				
				enum TypeInfo {
					Int = 0,
					Float,
					Double
				}
							
			''',			
			code: '''
				var x: TypeInfo = TypeInfo.Int
				assert(x == TypeInfo.Int)  
			'''
		},
		{
			name: "Enum different args",
			definitions: '''				
				enum TypeInfo {
					Int = 12,
					Float = 54,
					Double = 166
				}
							
			''',			
			code: '''
				var x = TypeInfo.Int
				var y = TypeInfo.Float as (i32)
				assert(x == TypeInfo.Int)  
				assert(y == 54)
				assert(TypeInfo.Int as (i32) == 12)
				assert(TypeInfo.Float as (i32) == 54)
				assert(TypeInfo.Double as (i32) == 166)
			'''
		},
		{
			name: "Enum in struct",
			definitions: '''	
				struct Type {			
					enum TypeInfo {
						Int = 12,
						Float = 54,
						Double = 166
					}
				}
							
			''',			
			code: '''
				var x = Type{TypeInfo.Int}
				var y = TypeInfo.Float as (i32)
				assert(x.TypeInfo == TypeInfo.Int)
			'''
		},
		{
			name: "Constant",					
			code: '''
				const x = 1024				
				assert(x == 1024)
			'''
		},
		{
			name: "Invalid Constant reassign",					
			code: '''
				const x = 1024
				x = 10
				assert(x == 1024)
			''',
			error: "can't reassign constant variable 'x'"
		},
		{
			name: "Generics struct and function",
			definitions: '''
				@include("stdlib.h");

				@foreign func malloc(size: u64) : void*;
								
				struct Array<T> {
					size: i32
					capacity: i32
					elements: T*
				}
				
				func ArrayInit<T>(a: Array<T>**, initialSize: i32) {
				    var size = sizeof(Array<T>) + (sizeof(T) * initialSize as (u64));
					*a = malloc(size) as (Array<T>*);
					(*a).size = 0;
					(*a).capacity = initialSize;	
					(*a).elements =	(*a + sizeof(Array<T>)) as (T*)				
				}
				
				func ArrayAdd<T>(a: Array<T>*, element: T) {
				    a.elements[a.size] = element;
				    a.size += 1
				}
							
			''',			
			code: '''
				var a : Array<i32>* = null;
				ArrayInit<i32>(&a, 23);
				
				assert(a);
				assert(a.capacity == 23)
				assert(a.size == 0);
				
				ArrayAdd<i32>(a, 4)
				assert(a.elements[0] == 4)
				  
			'''
		},
		{
            name: "Generics with greaterthan sign",
            definitions: '''                
                func test<T>(a: T) : T {
                    return a
                }
                            
            ''',            
            code: '''
                var x = test<i32> (4) < 5;
                assert(x)
            '''
        },
        {
            name: "Generics with greaterthan sign cast",
            definitions: '''                
                struct Test<T> {
                    u: T
                }
                            
            ''',            
            code: '''
                var a: Test<i32>{}
                var b: Test<f32>{}
                var x = a as (Test<f32>) > 0
                assert(x)
            ''',
            error: "illegal, left operand has type 'Testf32'"
        },
		{
            name: "Break Generics via Expression",                       
            code: '''
                var a = 1
                var b = 2
                var c = a < b > 2
                assert(!c)
            ''',           
        },
        {
            name: "Break Generics via Cast",
            definitions: '''                
                struct Test {
                    u: i32
                }
                            
            ''',                       
            code: '''
                var a = Test {}
                var b = 2
                var c = a as (Test) < b > 2
                assert(!c)                                
            ''',
            error: "illegal, left operand has type 'Test'"                      
        },
        {
            name: "Break Generics via Sizeof",
            definitions: '''                
                struct Test {
                    u: i32
                }
                            
            ''',                       
            code: '''                
                var b = 1
                var c = sizeof(Test < b > 0)                                               
            ''',
            error: "illegal, left operand has type 'Test'"                      
        },
        {
            name: "Typedef primitives",
            definitions: '''                
                typedef i32 as int;
                            
            ''',                       
            code: '''                
                var b : int = 1
                assert(b == 1)                                               
            '''                      
        },
        {
            name: "Typedef struct",
            definitions: '''
                typedef i32 as int;
                struct X {a:int}
                typedef X as Y;    
                            
            ''',                       
            code: '''                
                var y  = Y{1}
                var x  = X{2}
                assert(y.a == 1)
                assert(x.a == 2)                                               
            '''                      
        },
        {
            name: "Typedef struct generics",
            definitions: '''
                struct X<T> {a:T}
                typedef X<i32> as Y;    
                            
            ''',                       
            code: '''                
                var y  = Y{1}
                assert(y.a == 1)
            '''                      
        },
        {
            name: "Typedef func",
            definitions: '''
                func test(i:i32) : i32 {
                    return i;
                }
                
                typedef test as test2;    
                            
            ''',                       
            code: '''                
                assert(test2(1) == 1)
            '''                      
        },
        {
            name: "Typedef func generics",
            definitions: '''
                func test<T>(i:T) : T {
                    return i;
                }
                
                typedef test<i32> as test2;    
                            
            ''',                       
            code: '''                
                assert(test2(1) == 1)
            '''                      
        },
        {
            name: "Func type",
            definitions: '''
                func test(i:i32) : i32 {
                    return i;
                }
                            
            ''',                       
            code: '''                
                var t : func(i32) : i32 = &test;
                assert(t(1) == 1)
            '''                      
        },
        {
            name: "Func type as return type",
            definitions: '''
                func test(i:i32) : i32 {
                    return i;
                }
                    
                func x() : func(i32) : i32 {
                    return &test
                }
                            
            ''',                       
            code: '''                
                var t : func(i32) : i32 = x();
                assert(t(1) == 1)
            '''                      
        },
        {
            name: "Func type as argument and return type",
            definitions: '''
                func test(i:i32) : i32 {
                    return i;
                }
                    
                func x(f : func(i32):i32) : func(i32) : i32 {
                    return f
                }
                            
            ''',                       
            code: '''                
                var t : func(i32) : i32 = x(&test);
                assert(t(1) == 1)
            '''                      
        },
        {
            name: "Func type in struct",
            definitions: '''
                func test(i:i32) : i32 {
                    return i;
                }
                    
                struct Test {
                    a: func(i32) : i32
                }
                            
            ''',                       
            code: '''                
                var t = Test { &test }
                assert(t.a(1) == 1)
            '''                      
        },
        {
            name: "Func type in union",
            definitions: '''
                func test(i:i32) : i32 {
                    return i;
                }
                    
                union Test {
                    a: func(i32) : i32
                    b: void*
                }
                            
            ''',                       
            code: '''                
                var t = Test { .a: &test }
                assert(t.a(1) == 1)
            '''                      
        },
        {
            name: "ReadME Generics",
            definitions: '''
                
                // Defines a generic structure
                struct Vec2<T> {
                    x: T
                    y: T
                }
                
                // Defines a generic function
                func Vec2Add<T>(a: Vec2<T>, b: Vec2<T>, out: Vec2<T>) : Vec2<T> {
                    out.x = a.x + b.x
                    out.y = a.y + b.y
                    return out
                }
                
                // You alias this type
                typedef Vec2<i32> as Vec2i
                            
            ''',                       
            code: '''                
                
                var origin = Vec2<f32> { 0.0, 0.0 }  // using generics syntax
                var vel    = Vec2i { 0,0 }           // using the alias
                
                Vec2Add<i32>(vel, vel, vel)
                Vec2Add<f32>(origin, origin, origin)

            '''                      
        },
        { 
            name: "Generic Func Ptr in Struct",
            definitions: '''
                
                // Defines a generic structure
                struct Test<T> {
                    y: func<T>(T):T
                }

                func test(a:i32) : i32 {
                    return a;
                }                
                            
            ''',                       
            code: '''                
                
                var t = Test<i32> { &test }
                assert(t.y(1) == 1)
            '''                      
        },
        { 
            name: "Generic Func Ptr in Struct x2",
            definitions: '''
                
                struct Test<T> {
                    y: func<T>(T):T
                }

                func test(a:i32) : i32 {
                    return a;
                }                
                func test2(a:f32) : f32 {
                    return a;
                }            
            ''',                       
            code: '''                
                
                var t = Test<i32> { &test }
                assert(t.y(1) == 1)
                
                var t2 = Test<f32> { &test2 }
                assert(t2.y(1.4) == 1.4)
            '''                      
        },        
        {
            name: "Generic Func Ptr in Func",
            definitions: '''
                func test(a:i32) : i32 {
                    return a;
                }                
                
                func gen<T>(a: func<T>(T):T, b: T) : T {
                    return a<T>(b);
                }
                            
            ''',                       
            code: '''                
                
                var t = gen<i32>(&test, 24)
                assert(t == 24)
            '''                      
        },
        {
            name: "Invalid Generic Func Ptr in Func",
            definitions: '''
                func test(a:f32) : f32 {
                    return a;
                }                
                
                func gen<T>(a: func<T>(T):T, b: T) : T {
                    return a<T>(b);
                }
                            
            ''',                       
            code: '''                
                
                var t = gen<i32>(&test, 24)
                assert(t == 24)
            ''',
            error: "'func(i32) : i32' is not of type 'func(f32) : f32'"                      
        },
        {
            name: "Generic of Generic",
            definitions: '''
                struct B<T> {
                    y : T
                }
                
                struct A<T> {
                    x : T*
                }
            ''',                       
            code: '''     
                var b = B<i32> {4};           
                var a = A<B<i32>> {
                    .x: &b
                }
                
                assert(a.x.y == 4)
            ''',                      
        },        
        {
            name: "Fix sizeof and as bug",
            definitions: '''
                func t(i:i64) : i64 {
                    return i
                }
            ''',                       
            code: '''                
                var ln = 2_i64;
                const n = t(sizeof(char) as (i64) * (ln + 1_i64)) as (i32);
                assert(n);
            ''',
        },
        {
            name: "Function Default Arguments",
            definitions: '''
                func t(i:i32 = 2) : i32 {
                    return i
                }
            ''',                       
            code: '''                
                assert(t(4) == 4);
                assert(t()  == 2);
            ''',
        },
        {
            name: "Invalid Function Default Arguments",
            definitions: '''
                func t(i:i32 = 2, j:i32) : i32 {
                    return i
                }
            ''',                       
            code: '''                
                assert(false);
            ''',
            error: "'t' must have default arguments defined last"
        },
        {
            name: "Function Default Arguments null",
            definitions: '''
                func t(i:i32* = null) : i32 {
                    if(!i) return 2;
                    return *i
                }
            ''',                       
            code: '''                
                var n = 4;
                assert(t(&n) == 4);
                assert(t()  == 2);
            ''',
        },
        {
            name: "Function Default Arguments string",
            definitions: '''
                @include("string.h");
                @foreign func strcmp(a:char*, b:char*) : i32;
                
                func t(i:char* = "bye") : char* {
                    return i
                }
            ''',                       
            code: '''                
                assert(strcmp(t("hi"), "hi") == 0);
                assert(strcmp(t(), "bye") == 0);
            ''',
        },
        {
            name: "Function Default Arguments constant",
            definitions: '''
                const X = 2
                func t(i:i32 = X) : i32 {
                    return i
                }
            ''',                       
            code: '''                
                assert(t(4) == 4);
                assert(t()  == 2);
            ''',
        },
        {
            name: "Foreign Alias function",
            definitions: '''
                @include("<string.h>");
                
                @foreign("strcmp") 
                func stringCompare(a:char*, b:char*) : i32;
            ''',                       
            code: '''                
                assert(stringCompare("hi", "bye") != 0);
                assert(stringCompare("hi", "hi") == 0);
            ''',
        },
        {
            name: "Foreign Alias Const",
            definitions: '''
                @include("<stdio.h>");
                
                @foreign("SEEK_END") 
                var END : i32; 
            ''',                       
            code: '''   
                assert(END == 2)             
            ''',
        },
        {
            name: "Foreign Alias Struct",
            definitions: '''
                @include("<stdio.h>");
                
                @foreign("FILE") 
                struct File; 
                
                @foreign public func fopen(fileName:char*, openType:char*) : File*;
            ''',                       
            code: '''   
                var t: File* = fopen("../examples/unions.lita", "r")
                assert(t != null)             
            ''',
        },
        {
            name: "Array Designator",
            definitions: '''
            
            ''',                       
            code: '''   
                var t = [256]i32 {
                    [0] = 2,
                    [128] = 1
                }
                assert(t[0] == 2);
                assert(t[128] == 1);
                
                for(var i = 0; i < 256; i +=1) {
                    if(i == 0 || i == 128) {
                        continue;
                    }
                    assert(t[i] == 0)
                }             
            ''',
        },
        {
            name: "Array Designator with constant",
            definitions: '''
            
            ''',                       
            code: '''   
                const I = 0;
                const Y = 128;
                var t = [256]i32 {
                    [I] = 2,
                    [Y] = 1
                }
                assert(t[0] == 2);
                assert(t[128] == 1);
                
                for(var i = 0; i < 256; i +=1) {
                    if(i == 0 || i == 128) {
                        continue;
                    }
                    assert(t[i] == 0)
                }             
            ''',
        },
        {
            name: "Array Designator with enum",
            definitions: '''
                enum Index {
                    I = 2,
                    Y = 1
                }
            ''',                       
            code: '''   
                var t = [256]i32 {
                    [Index.I] = 2,
                    [Index.Y] = 1
                }
                assert(t[Index.I] == 2);
                assert(t[Index.Y] == 1);
                
                for(var i = 0; i < 256; i +=1) {
                    if(i == Index.I || i == Index.Y) {
                        continue;
                    }
                    assert(t[i] == 0)
                }             
            ''',
        },
        {
            name: "Array Designator with variable",
            definitions: '''
                var index = 0
                var index2 = 128
            ''',                       
            code: '''   
                var t = [256]i32 {
                    [index] = 2,
                    [index2] = 1
                }
                assert(t[0] == 2);
                assert(t[128] == 1);
                
                for(var i = 0; i < 256; i +=1) {
                    if(i == 0 || i == 128) {
                        continue;
                    }
                    assert(t[i] == 0)
                }             
            ''',
            error: "must be a constant"
        },
        {
            name: "Array NonDesignator",
            definitions: '''
                
            ''',                       
            code: '''   
                var t = [1][2]i32 {
                    [2]i32 { 1, 2 }
                }
                assert(t[0][0] == 1);
                assert(t[0][1] == 2);             
            ''',
        },
        {
            name: "For loops",
            definitions: '''
                
            ''',                       
            code: '''   
                var t = [1]i32 {
                    0
                }
                
                var iterations = 0;
                for(var i = 0; i < 1; i+=1) {
                    iterations += 1
                }
                
                assert(iterations == 1);
                
                iterations = 0;
                var i =0;
                for(; i < 1; i+=1) {
                    iterations += 1
                }
                
                assert(iterations == 1);
                
                iterations = 0;
                i = 0;
                for(;; i+=1) {
                    if(i >= 2) break;
                    iterations += 1
                }             
                
                assert(iterations == 2);
                
                iterations = 0;
                i = 0;
                for(;;) {
                    if(i >= 2) break;
                    i += 1;
                    iterations += 1
                }             
                
                assert(iterations == 2);
            ''',
        },
        {
            name: "Struct DuplicateFieldNames",
            definitions: '''
                struct X {
                    x: i32
                    x: f32
                }
            ''',                       
            code: '''   
                             
            ''',
            error: "duplicate member 'x'"
        },
        {
            name: "Enum DuplicateFieldNames",
            definitions: '''
                enum X {
                    x,
                    x
                }
            ''',                       
            code: '''   
                             
            ''',
            error: "duplicate member 'x'"
        },
        {
            name: "Union DuplicateFieldNames",
            definitions: '''
                union X {
                    x: i32
                    x: f32
                }
            ''',                       
            code: '''   
                             
            ''',
            error: "duplicate member 'x'"
        },
        {
            name: "UsingStruct",
            definitions: '''
                struct Vec {
                    x: f32
                    y: f32
                }
                struct Entity {
                    pos: using Vec
                    type: i32
                }
            ''',                       
            code: '''   
                var e = Entity{.pos: Vec{1.0,2.0}, .type: 1};
                assert(e.x == 1.0);
                assert(e.y == 2.0);
                
                e.x = 3.0;
                e.y = 4.0;
                
                assert(e.x == 3.0);
                assert(e.y == 4.0);
            ''',            
        },
        {
            name: "UsingStruct with conflict",
            definitions: '''
                struct Vec {
                    x: f32
                    y: f32
                }
                struct Entity {
                    pos: using Vec
                    x: i32
                }
            ''',                       
            code: '''   
                assert(false);
            ''', 
            error: "duplicate member 'x' from 'Entity' and 'Vec'"           
        },
        {
            name: "UsingStructDeep",
            definitions: '''
                struct X {
                    x:f32
                }
                
                struct Vec {
                    e: using X
                    y: f32
                }
                struct Entity {
                    type: i32
                    pos: using Vec
                }
            ''',                       
            code: '''   
                var e = Entity{.pos: Vec{ .e: X{1.0} ,2.0}, .type: 1};
                assert(e.x == 1.0);
                assert(e.y == 2.0);
                
                e.x = 3.0;
                e.y = 4.0;
                
                assert(e.x == 3.0);
                assert(e.y == 4.0);
            ''',            
        },
        {
            name: "UsingStructDeepPointer",
            definitions: '''
                struct X {
                    x:f32
                }
                
                struct Vec {
                    e: using X*
                    y: f32
                }
                struct Entity {
                    type: i32
                    pos: using Vec
                }
            ''',                       
            code: '''   
                var xx = X{1.0};
                var e = Entity{.pos: Vec{ .e: &xx ,2.0}, .type: 1};
                assert(e.x == 1.0);
                assert(e.y == 2.0);
                
                e.x = 3.0;
                e.y = 4.0;
                
                assert(e.x == 3.0);
                assert(e.y == 4.0);
            ''',            
        },
        { 
            name: "Struct Independent declaration",
            definitions: '''
                struct A {
                    x : B
                }
                struct B {
                    y : i32
                }
            ''',                       
            code: '''                           
                var a = A {
                    .x: B {4}
                }
                
                assert(a.x.y == 4)
            ''',                      
        },
        { 
            name: "Struct Independent declaration Pointer",
            definitions: '''
                struct A {
                    x : B*
                }
                struct B {
                    y : i32
                }
            ''',                       
            code: '''                           
                var a = A {
                    .x: &B {4}
                }
                
                assert(a.x.y == 4)
            ''',                      
        },
        { 
            name: "Var Independent declaration",
            definitions: '''                
                var b = B{14}
                var a = A {
                    .x: B {4}
                }
                
                struct A {
                    x : B
                }
                struct B {
                    y : i32
                }
            ''',                       
            code: '''                           
                assert(a.x.y == 4)
                assert(b.y == 14)
            ''',                      
        },
        { 
            name: "Var Independent declaration pointer",
            definitions: '''                
                var b = B{14}
                var a = A {
                    .x: &B {4}
                }
                
                struct A {
                    x : B*
                }
                struct B {
                    y : i32
                }
            ''',                       
            code: '''                           
                assert(a.x.y == 4)
                assert(b.y == 14)
            ''',                      
        },
        { 
            name: "Func Independent declaration pointer",
            definitions: '''
                func test(a: A) : i32 {
                    return a.x.y;
                }                
                                
                struct A {
                    x : B*
                }
                struct B {
                    y : i32
                }
            ''',                       
            code: '''            
                var a = A {
                    .x: &B {4}
                }                           
                assert(test(a) == 4)                                
            ''',                      
        },
        { 
            name: "Func Independent declaration",
            definitions: '''
                func test(a: A) : i32 {
                    return a.x.y;
                }                
                                
                struct A {
                    x : B
                }
                struct B {
                    y : i32
                }
            ''',                       
            code: '''            
                var a = A {
                    .x: B {4}
                }                           
                assert(test(a) == 4)                                
            ''',                      
        },
        { 
            name: "Func Independent declaration Generics",
            definitions: '''
                func test<T>(a: T) : i32 {
                    return a.x.y;
                }                
                                
                struct A {
                    x : B
                }
                struct B {
                    y : i32
                }
            ''',                       
            code: '''            
                var a = A {
                    .x: B {4}
                }                           
                assert(test<A>(a) == 4)                                
            ''',                      
        },
        { 
            name: "Var Independent declaration Generics",
            definitions: '''                
                var b = B<i32>{14}
                var a = A<B<i32>> {
                    .x: B<i32> {4}
                }
                
                struct A<T> {
                    x : T
                }
                struct B<T> {
                    y : T
                }
            ''',                       
            code: '''                           
                assert(a.x.y == 4)
                assert(b.y == 14)
            ''',                      
        },
        { 
            name: "Func arg using",
            definitions: '''                
                func test(a : using A) : i32 {
                    return x
                }
                struct A {
                    x : i32
                }
                
            ''',                       
            code: '''                           
                assert(test( A{.x: 4}) == 4)
            ''',                      
        },
        { 
            name: "Func arg pointer using",
            definitions: '''                
                func test(a : using A*) : i32 {
                    return x
                }
                struct A {
                    x : i32
                }
                
            ''',                       
            code: '''                           
                assert(test( &A{.x: 4}) == 4)
            ''',                      
        },
        { 
            name: "Invalid Func arg using",
            definitions: '''                
                func test(a : using A**) : i32 {
                    return 1
                }
                struct A {
                    x : i32
                }
                
            ''',                       
            code: '''                           

            ''', 
            error: "'a' is not an aggregate type (or pointer to an aggregate), can't use 'using'"                     
        },
        { 
            name: "Func arg scoped shadow using",
            definitions: '''   
                func test(a : using A*) : i32 {
                    var x = 43
                    return x
                }
                struct A {
                    x : i32
                }
                
            ''',                       
            code: '''      
                var x = test(&A{.x: 4});
                assert(x == 43)
            ''', 
        },
        { 
            name: "Func arg scoped shadow scoping using",
            definitions: '''                
                func test(a : using A*) : i32 {
                    {var x = 43}
                    return x
                }
                struct A {
                    x : i32
                }
                
            ''',                       
            code: '''                           
                assert(test( &A{.x: 4}) == 4)
            ''', 
        },
        { 
            name: "Func arg scoped shadow scoping using with embedded using",
            definitions: '''                
                func test(a : using A) : i32 {
                    return y
                }
                struct A {
                    x : using B
                }
                struct B {
                    y : i32
                }
                
            ''',                       
            code: '''  
                assert(test(A{.x: B{.y: 4}}) == 4)
            ''', 
        },
        { 
            name: "Func arg scoped shadow scoping using with embedded using use fullpath",
            definitions: '''                
                func test(a : using A) : i32 {
                    return a.x.y
                }
                struct A {
                    x : using B
                }
                struct B {
                    y : i32
                }
                
            ''',                       
            code: '''  
                assert(test(A{.x: B{.y: 4}}) == 4)
            ''', 
        },
        { 
            name: "Const Ptr",
            definitions: '''                
                
            ''',                       
            code: '''  
                var t : char const* = "Hello";
                assert(t)
            ''', 
        },
        
        { 
            name: "Invalid Const assign to non-const",
            definitions: '''         
                
            ''',                       
            code: '''  
                var t : char const* = "Hello"
                var x : char* = t                
            ''', 
            error: "'char const*' is not of type 'char*'"
        },
        { 
            name: "Assign no const",
            definitions: '''         
                
            ''',                       
            code: '''  
                var t : char* = "Hello"
                var x : char* = t
                assert(t == x)                
            ''',             
        },
        { 
            name: "ArrayInt const",
            definitions: '''         
                
            ''',                       
            code: '''  
                var t : []i32 const = []i32 const {1,2,3}                               
            ''',             
        },*/
        { 
            name: "PtrInt const",
            definitions: '''         
                
            ''',                       
            code: '''  
                var t : i32 const* = []i32 const {1,2,3} as (i32 const*)                               
            ''',             
        },/*
        { 
            name: "Func Const Ptr Param",
            definitions: '''         
                // TODO Return param       
                func test(a: char const*) : char const* {
                    return a
                }
            ''',                       
            code: '''  
                var t = test("Hello")
                assert(t)
            ''', 
        },
        { 
            name: "Array Ptr assign",
            definitions: '''         
                @include("<stdlib.h>");
                @foreign public func malloc(size: u64) : void*;
            ''',                       
            code: '''  
                var t = malloc( sizeof(char) * 3_u64) as (char*);
                t[0] = 'h';
                t[1] = 'i';
                t[2] = '\0';
                
                assert(t[0] == 'h');
                assert(t[1] == 'i');
                assert(t[2] == '\0');
            ''', 
        },
        { 
            name: "Generics Struct with No GenArgs",
            definitions: '''         
                struct X<T> {
                    y: T
                }
            ''',                       
            code: '''  
                var t = X{}
            ''',
            error: "incorrect number of generic argument types, requires 1 and has 0" 
        },
        { 
            name: "Generics Union with No GenArgs",
            definitions: '''         
                union X<T> {
                    y: T
                }
            ''',                       
            code: '''  
                var t = X{}
            ''',
            error: "incorrect number of generic argument types, requires 1 and has 0" 
        },
        { 
            name: "Generics Func with No GenArgs",
            definitions: '''         
                func test<T>() {
                }
            ''',                       
            code: '''  
                test()
            ''',
            error: "incorrect number of generic argument types, requires 1 and has 0" 
        },
        { 
            name: "Generics Var mismatch Types",
            definitions: '''         
                struct X<T> {
                    y : T
                }
            ''',                       
            code: '''  
                var x : X<i32> = X<f32>{}
            ''',
            error: "'struct Xf32' is not of type 'struct Xi32'" 
        },
        { 
            name: "Generics Var mismatch Types no GenArgs",
            definitions: '''         
                struct X<T> {
                    y : T
                }
            ''',                       
            code: '''  
                var x : X = X<f32>{}
            ''',
            error: "'struct Xf32' is not of type 'struct X'" 
        },
        { 
            name: "Generics Var mismatch Types no GenArgs Init",
            definitions: '''         
                struct X<T> {
                    y : T
                }
            ''',                       
            code: '''  
                var x : X<f32> = X{}
            ''',
            error: "incorrect number of generic argument types, requires 1 and has 0" 
        },*/
	]
}
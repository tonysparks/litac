{
	description: "Tests Declarations",
	program: '''				
		@include("assert.h");
		@foreign func assert(e:bool):void;
		
		%definitions%
		
		func main(len:i32, args:char**):i32 {
			%test%
		}
	'''
	tests: [		
		{
			name: "Primatives",
			code: '''
				var i = 32
				assert( i == 32 )
				
				var j = 64_i64
				assert( j == 64_i64 )
				
				var b = false
				assert( !b )
				b = true
				assert(b)
				
				var f = 45.756
				assert(f == 45.756)
				
				var d = 245.756_f64
				assert(d == 245.756_f64)
				
				var p = "hello"				
				assert(p)
				assert(p[0] == 'h')
				
				var index = p
				var k = 0
				while (*index) {
					assert(p[k] == *index)
					index += 1
					k += 1
				}
				  
			'''
		}, 
		{
			name: "Casts",
			definitions: '''
				struct T {
					v: i32
				}
				
				struct X<T> {
					v: T
				}
							
			''',			
			code: '''
				var i : i64 = 32 as (i64) + 45_i64
				assert( i == 77_i64 )
				
				
				i = 2_i64*32 as (i64) + 45_i64
				assert( i == 109_i64 )

				
				var t = T { 4}
				var x = X<i32> {44} as (X<i32>)
				  
			'''
		}, 
		{
			name: "Invalid struct Casts",
			definitions: '''				
				struct X<T> {
					v: T
				}
							
			''',			
			code: '''
				var x = X<i32> {44} as (X<f32>)
				  
			''',
			error: "'struct Xf32' can't be casted to 'struct Xi32'"
		},
		{
			name: "Invalid union Casts",
			definitions: '''				
				union X<T> {
					v: T
				}
							
			''',			
			code: '''
				var x = X<i32> {44} as (X<f32>)
				  
			''',
			error: "'union Xf32' can't be casted to 'union Xi32'"
		},
		{
			name: "Generics struct with union",
			definitions: '''				
				struct Person<T> {
					union X<T> {
						v: T
					}
				}
							
			''',			
			code: '''
				var x = Person<i32> { .X: X<i32>{4} }				
				assert(x.X.v == 4)
				  
			'''
		},
		{
			name: "Generics struct within union and generic field",
			definitions: '''				
				struct Person<T> {
					union X<T> {
						v: T
					}
					age: T
				}
							
			''',			
			code: '''
				var x = Person<i32> { .X: X<i32>{4}, .age:56 }				
				assert(x.X.v == 4)
				assert(x.age == 56)  
			'''
		},
		{
			name: "Generics struct within union and field",
			definitions: '''				
				struct Person<T> {
					union X<T> {
						v: T
					}
					age: i64
				}
							
			''',			
			code: '''
				var x = Person<i32> { .X: X<i32>{4}, .age:56_i64 }				
				assert(x.X.v == 4)
				assert(x.age == 56_i64)  
			'''
		},
		{
			name: "Enum",
			definitions: '''				
				enum TypeInfo {
					Int = 0,
					Float,
					Double
				}
							
			''',			
			code: '''
				var x: TypeInfo = TypeInfo.Int
				assert(x == TypeInfo.Int)  
			'''
		},
		{
			name: "Enum different args",
			definitions: '''				
				enum TypeInfo {
					Int = 12,
					Float = 54,
					Double = 166
				}
							
			''',			
			code: '''
				var x = TypeInfo.Int
				var y = TypeInfo.Float as (i32)
				assert(x == TypeInfo.Int)  
				assert(y == 54)
				assert(TypeInfo.Int as (i32) == 12)
				assert(TypeInfo.Float as (i32) == 54)
				assert(TypeInfo.Double as (i32) == 166)
			'''
		},
		{
			name: "Enum in struct",
			definitions: '''	
				struct Type {			
					enum TypeInfo {
						Int = 12,
						Float = 54,
						Double = 166
					}
				}
							
			''',			
			code: '''
				var x = Type{TypeInfo.Int}
				var y = TypeInfo.Float as (i32)
				assert(x.TypeInfo == TypeInfo.Int)
			'''
		},
		{
			name: "Constant",					
			code: '''
				const x = 1024				
				assert(x == 1024)
			'''
		},
		{
			name: "Invalid Constant reassign",					
			code: '''
				const x = 1024
				x = 10
				assert(x == 1024)
			''',
			error: "can't reassign constant variable 'x'"
		},
		{
			name: "Generics struct and function",
			definitions: '''
				@include("stdlib.h");

				@foreign func malloc(size: u64) : void*;
								
				struct Array<T> {
					size: i32
					capacity: i32
					elements: T*
				}
				
				func ArrayInit<T>(a: Array<T>**, initialSize: i32) {
				    var size = sizeof(Array<T>) + (sizeof(T) * initialSize as (u64));
					*a = malloc(size) as (Array<T>*);
					(*a).size = 0;
					(*a).capacity = initialSize;	
					(*a).elements =	(*a + sizeof(Array<T>)) as (T*)				
				}
				
				func ArrayAdd<T>(a: Array<T>*, element: T) {
				    if(a.size + 1 > a.capacity) {
				        // grow
				    }
				    a.elements[a.size] = element;
				    a.size += 1
				}
							
			''',			
			code: '''
				var a : Array<i32>* = null;
				ArrayInit<i32>(&a, 23);
				
				assert(a);
				assert(a.capacity == 23)
				assert(a.size == 0);
				
				ArrayAdd<i32>(a, 4)
				assert(a.elements[0] == 4)
				  
			'''
		},
		{
            name: "Generics with greaterthan sign",
            definitions: '''                
                func test<T>(a: T) : T {
                    return a
                }
                            
            ''',            
            code: '''
                var x = test<i32> (4) < 5;
                assert(x)
            '''
        },
        {
            name: "Generics with greaterthan sign cast",
            definitions: '''                
                struct Test<T> {
                    u: T
                }
                            
            ''',            
            code: '''
                var a: Test<i32>{}
                var b: Test<f32>{}
                var x = a as (Test<f32>) > 0
                assert(x)
            ''',
            error: "illegal, left operand has type 'Testf32'"
        },
		{
            name: "Break Generics via Expression",                       
            code: '''
                var a = 1
                var b = 2
                var c = a < b > 2
                assert(!c)
            ''',           
        },
        {
            name: "Break Generics via Cast",
            definitions: '''                
                struct Test {
                    u: i32
                }
                            
            ''',                       
            code: '''
                var a = Test {}
                var b = 2
                var c = a as (Test) < b > 2
                assert(!c)                                
            ''',
            error: "illegal, left operand has type 'Test'"                      
        },
        {
            name: "Break Generics via Sizeof",
            definitions: '''                
                struct Test {
                    u: i32
                }
                            
            ''',                       
            code: '''                
                var b = 1
                var c = sizeof(Test < b > 0)                                               
            ''',
            error: "illegal, left operand has type 'Test'"                      
        },
        {
            name: "Typedef primitives",
            definitions: '''                
                typedef i32 as int;
                            
            ''',                       
            code: '''                
                var b : int = 1
                assert(b == 1)                                               
            '''                      
        },
        {
            name: "Typedef struct",
            definitions: '''
                typedef i32 as int;
                struct X {a:int}
                typedef X as Y;    
                            
            ''',                       
            code: '''                
                var y  = Y{1}
                var x  = X{2}
                assert(y.a == 1)
                assert(x.a == 2)                                               
            '''                      
        },
        {
            name: "Typedef struct generics",
            definitions: '''
                struct X<T> {a:T}
                typedef X<i32> as Y;    
                            
            ''',                       
            code: '''                
                var y  = Y{1}
                assert(y.a == 1)
            '''                      
        },
        {
            name: "Typedef func",
            definitions: '''
                func test(i:i32) : i32 {
                    return i;
                }
                
                typedef test as test2;    
                            
            ''',                       
            code: '''                
                assert(test2(1) == 1)
            '''                      
        },
        {
            name: "Typedef func generics",
            definitions: '''
                func test<T>(i:T) : T {
                    return i;
                }
                
                typedef test<i32> as test2;    
                            
            ''',                       
            code: '''                
                assert(test2(1) == 1)
            '''                      
        },
        {
            name: "Func type",
            definitions: '''
                func test(i:i32) : i32 {
                    return i;
                }
                            
            ''',                       
            code: '''                
                var t : func(i32) : i32 = &test;
                assert(t(1) == 1)
            '''                      
        },
        {
            name: "Func type as return type",
            definitions: '''
                func test(i:i32) : i32 {
                    return i;
                }
                    
                func x() : func(i32) : i32 {
                    return &test
                }
                            
            ''',                       
            code: '''                
                var t : func(i32) : i32 = x();
                assert(t(1) == 1)
            '''                      
        },
        {
            name: "Func type as argument and return type",
            definitions: '''
                func test(i:i32) : i32 {
                    return i;
                }
                    
                func x(f : func(i32):i32) : func(i32) : i32 {
                    return f
                }
                            
            ''',                       
            code: '''                
                var t : func(i32) : i32 = x(&test);
                assert(t(1) == 1)
            '''                      
        },
        {
            name: "Func type in struct",
            definitions: '''
                func test(i:i32) : i32 {
                    return i;
                }
                    
                struct Test {
                    a: func(i32) : i32
                }
                            
            ''',                       
            code: '''                
                var t = Test { &test }
                assert(t.a(1) == 1)
            '''                      
        },
        {
            name: "Func type in union",
            definitions: '''
                func test(i:i32) : i32 {
                    return i;
                }
                    
                union Test {
                    a: func(i32) : i32
                    b: void*
                }
                            
            ''',                       
            code: '''                
                var t = Test { .a: &test }
                assert(t.a(1) == 1)
            '''                      
        },
        {
            name: "ReadME Generics",
            definitions: '''
                
                // Defines a generic structure
                struct Vec2<T> {
                    x: T
                    y: T
                }
                
                // Defines a generic function
                func Vec2Add<T>(a: Vec2<T>, b: Vec2<T>, out: Vec2<T>) : Vec2<T> {
                    out.x = a.x + b.x
                    out.y = a.y + b.y
                    return out
                }
                
                // You alias this type
                typedef Vec2<i32> as Vec2i
                            
            ''',                       
            code: '''                
                
                var origin = Vec2<f32> { 0.0, 0.0 }  // using generics syntax
                var vel    = Vec2i { 0,0 }           // using the alias
                
                Vec2Add<i32>(vel, vel, vel)
                Vec2Add<f32>(origin, origin, origin)

            '''                      
        },
        {
            name: "Generic Func Ptr in Struct",
            definitions: '''
                
                // Defines a generic structure
                struct Test<T> {
                    y: func<T>(T):T
                }

                func test(a:i32) : i32 {
                    return a;
                }                
                            
            ''',                       
            code: '''                
                
                var t = Test<i32> { &test }
                assert(t.y(1) == 1)
            '''                      
        },
        {
            name: "Generic Func Ptr in Func",
            definitions: '''
                func test(a:i32) : i32 {
                    return a;
                }                
                
                func gen<T>(a: func<T>(T):T, b: T) : T {
                    return a<T>(b);
                }
                            
            ''',                       
            code: '''                
                
                var t = gen<i32>(&test, 24)
                assert(t == 24)
            '''                      
        },
        {
            name: "Invalid Generic Func Ptr in Func",
            definitions: '''
                func test(a:f32) : f32 {
                    return a;
                }                
                
                func gen<T>(a: func<T>(T):T, b: T) : T {
                    return a<T>(b);
                }
                            
            ''',                       
            code: '''                
                
                var t = gen<i32>(&test, 24)
                assert(t == 24)
            ''',
            error: "'func<T>(i32) : i32' is not of type 'func(f32) : f32'"                      
        },
        {
            name: "Fix sizeof and as bug",
            definitions: '''
                func t(i:i64) : i64 {
                    return i
                }
            ''',                       
            code: '''                
                var ln = 2_i64;
                const n = t(sizeof(char) as (i64) * (ln + 1_i64)) as (i32);
                assert(n);
            ''',
        },
        {
            name: "Function Default Arguments",
            definitions: '''
                func t(i:i32 = 2) : i32 {
                    return i
                }
            ''',                       
            code: '''                
                assert(t(4) == 4);
                assert(t()  == 2);
            ''',
        },
        {
            name: "Invalid Function Default Arguments",
            definitions: '''
                func t(i:i32 = 2, j:i32) : i32 {
                    return i
                }
            ''',                       
            code: '''                
                assert(false);
            ''',
            error: "'t' must have default arguments defined last"
        },
        {
            name: "Function Default Arguments null",
            definitions: '''
                func t(i:i32* = null) : i32 {
                    if(!i) return 2;
                    return *i
                }
            ''',                       
            code: '''                
                var n = 4;
                assert(t(&n) == 4);
                assert(t()  == 2);
            ''',
        },
        {
            name: "Function Default Arguments string",
            definitions: '''
                @include("string.h");
                @foreign func strcmp(a:char*, b:char*) : i32;
                
                func t(i:char* = "bye") : char* {
                    return i
                }
            ''',                       
            code: '''                
                assert(strcmp(t("hi"), "hi") == 0);
                assert(strcmp(t(), "bye") == 0);
            ''',
        },
	]
}
/*
 * see license.txt
 */
package litac.lsp;

import org.junit.Test;

import com.google.gson.*;

import litac.LitaOptions;
import litac.lsp.JsonRpc.*;

/**
 * @author antho
 *
 */
public class RequestHandlerTest {

    @Test
    public void test() {
        LitaOptions options = new LitaOptions();
        
        Gson gson = new GsonBuilder()
                .serializeNulls()
                .create();
        
        LspLogger log = new LspLogger(false);
        MessageSender sender = new MessageSender(gson, log);
        RequestHandler handler = new RequestHandler(options, new Workspace(options, log), sender, log);
        
        String initJson = "{\"jsonrpc\":\"2.0\",\"id\":0,\"method\":\"initialize\",\"params\":{\"processId\":6476,\"rootPath\":\"c:\\\\Users\\\\antho\\\\git\\\\realm\",\"rootUri\":\"file:///c%3A/Users/antho/git/realm\",\"capabilities\":{\"workspace\":{\"applyEdit\":true,\"workspaceEdit\":{\"documentChanges\":true},\"didChangeConfiguration\":{\"dynamicRegistration\":true},\"didChangeWatchedFiles\":{\"dynamicRegistration\":true},\"symbol\":{\"dynamicRegistration\":true,\"symbolKind\":{\"valueSet\":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]}},\"executeCommand\":{\"dynamicRegistration\":true},\"configuration\":true,\"workspaceFolders\":true},\"textDocument\":{\"publishDiagnostics\":{\"relatedInformation\":true},\"synchronization\":{\"dynamicRegistration\":true,\"willSave\":true,\"willSaveWaitUntil\":true,\"didSave\":true},\"completion\":{\"dynamicRegistration\":true,\"contextSupport\":true,\"completionItem\":{\"snippetSupport\":true,\"commitCharactersSupport\":true,\"documentationFormat\":[\"markdown\",\"plaintext\"],\"deprecatedSupport\":true,\"preselectSupport\":true},\"completionItemKind\":{\"valueSet\":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]}},\"hover\":{\"dynamicRegistration\":true,\"contentFormat\":[\"markdown\",\"plaintext\"]},\"signatureHelp\":{\"dynamicRegistration\":true,\"signatureInformation\":{\"documentationFormat\":[\"markdown\",\"plaintext\"]}},\"definition\":{\"dynamicRegistration\":true},\"references\":{\"dynamicRegistration\":true},\"documentHighlight\":{\"dynamicRegistration\":true},\"documentSymbol\":{\"dynamicRegistration\":true,\"symbolKind\":{\"valueSet\":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},\"hierarchicalDocumentSymbolSupport\":true},\"codeAction\":{\"dynamicRegistration\":true,\"codeActionLiteralSupport\":{\"codeActionKind\":{\"valueSet\":[\"\",\"quickfix\",\"refactor\",\"refactor.extract\",\"refactor.inline\",\"refactor.rewrite\",\"source\",\"source.organizeImports\"]}}},\"codeLens\":{\"dynamicRegistration\":true},\"formatting\":{\"dynamicRegistration\":true},\"rangeFormatting\":{\"dynamicRegistration\":true},\"onTypeFormatting\":{\"dynamicRegistration\":true},\"rename\":{\"dynamicRegistration\":true},\"documentLink\":{\"dynamicRegistration\":true},\"typeDefinition\":{\"dynamicRegistration\":true},\"implementation\":{\"dynamicRegistration\":true},\"colorProvider\":{\"dynamicRegistration\":true},\"foldingRange\":{\"dynamicRegistration\":true,\"rangeLimit\":5000,\"lineFoldingOnly\":true}}},\"trace\":\"off\",\"workspaceFolders\":[{\"uri\":\"file:///c%3A/Users/antho/git/realm\",\"name\":\"realm\"}]}}";
        RpcRequest initReq = gson.fromJson(initJson, RpcRequest.class);
        InitializationParams initParams = gson.fromJson(initReq.params, InitializationParams.class);
        handler.handleInitialize(initReq, initParams);
        
//        String openJson = "{\"jsonrpc\":\"2.0\",\"method\":\"textDocument/didOpen\",\"params\":{\"textDocument\":{\"uri\":\"file:///c%3A/Users/antho/git/kraft/src/renderer.lita\",\"languageId\":\"litac\",\"version\":1,\"text\":\"import \\\"opengl\\\"\\r\\nimport \\\"cglm/cglm\\\"\\r\\nimport \\\"shader\\\"\\r\\nimport \\\"entity\\\"\\r\\nimport \\\"model\\\"\\r\\n\\r\\npublic func Prepare() {    \\r\\n    glEnable(GL_DEPTH_TEST)    \\r\\n    //glLogicOp(GL_INVERT)\\r\\n//    glEnable(GL_BLEND)\\r\\n//    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)\\r\\n    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)\\r\\n    glClearColor(0f, 0.5f, 0.75f, 1f)    \\r\\n}\\r\\n\\r\\npublic func BatchEntityRender(entities: Entity*, len: i32, model: Model*, shader: ShaderProgram, viewMatrix: mat4) {\\r\\n    shader.bind()\\r\\n    shader.loadMat4ByName(\\\"viewMatrix\\\", viewMatrix)\\r\\n    shader.loadFloatByName(\\\"shineDamper\\\", 10f)\\r\\n    shader.loadFloatByName(\\\"reflectivity\\\", 1f)\\r\\n\\r\\n    glEnableVertexAttribArray(AttribPos.POSITION)\\r\\n    glEnableVertexAttribArray(AttribPos.NORMAL)\\r\\n    glEnableVertexAttribArray(AttribPos.TEXCOORD)\\r\\n    \\r\\n    glBindVertexArray(model.vao)\\r\\n    glActiveTexture(GL_TEXTURE0)\\r\\n    glBindTexture(GL_TEXTURE_2D, model.tex.texId)\\r\\n\\r\\n    var transformMatrix: mat4;\\r\\n\\r\\n    for(var i = 0; i < len; i +=1) {\\r\\n        var ent = &entities[i]\\r\\n        ent.transform(transformMatrix)\\r\\n        shader.loadMat4ByName(\\\"transformationMatrix\\\", transformMatrix)\\r\\n\\r\\n        glDrawElements(GL_TRIANGLES, model.indexCount, GL_UNSIGNED_INT, 0)\\r\\n    }\\r\\n    \\r\\n    glDisableVertexAttribArray(AttribPos.POSITION)\\r\\n    glDisableVertexAttribArray(AttribPos.NORMAL)\\r\\n    glDisableVertexAttribArray(AttribPos.TEXCOORD)\\r\\n\\r\\n    shader.unbind()\\r\\n}\"}}}";
        //String openJson = "{\"jsonrpc\":\"2.0\",\"method\":\"textDocument/didOpen\",\"params\":{\"textDocument\":{\"uri\":\"file:///c%3A/Users/antho/git/kraft/src/main.lita\",\"languageId\":\"litac\",\"version\":1,\"text\":\"import \\\"io\\\"\\r\\nimport \\\"common\\\"\\r\\nimport \\\"input_system\\\"\\r\\nimport \\\"game\\\"\\r\\n\\r\\n\\r\\nimport \\\"opengl\\\"\\r\\nimport \\\"glfw\\\"\\r\\nimport \\\"model\\\"\\r\\nimport \\\"renderer\\\"\\r\\nimport \\\"texture\\\"\\r\\nimport \\\"shader\\\"\\r\\nimport \\\"camera\\\"\\r\\nimport \\\"light\\\"\\r\\nimport \\\"entity\\\"\\r\\nimport \\\"math\\\"\\r\\nimport \\\"obj_loader\\\"\\r\\nimport \\\"block\\\"\\r\\nimport \\\"chunk\\\"\\r\\n\\r\\nimport \\\"libc\\\" as c\\r\\n\\r\\nimport \\\"cglm/cglm\\\"\\r\\n\\r\\n\\r\\n@cFile(\\\"glad.h\\\");\\r\\n@raw(\\\"\\\"\\\"\\r\\n#include <GLFW/glfw3.h>\\r\\n#include <cglm/cglm.h>\\r\\n\\\"\\\"\\\");\\r\\n\\r\\nimport \\\"stb_image\\\" as stb;\\r\\n\\r\\nconst WIDTH = 1280\\r\\nconst HEIGHT = 720\\r\\n\\r\\nconst FOV = 90f\\r\\nconst NEAR_PLANE = 0.01f\\r\\nconst FAR_PLANE  = 10_000f\\r\\n\\r\\nvar isRunning = false;\\r\\n//var REMOVE_ME : Test;\\r\\n/*\\r\\nvar model = Model{};\\r\\nvar model2 = Model{};\\r\\n*/\\r\\n\\r\\nfunc array_length<T>(array: T*) : i32 {\\r\\n    return (sizeof(array) / sizeof(array[0])) as (i32)\\r\\n}\\r\\n\\r\\nvar texture: Texture;\\r\\nvar shader: ShaderProgram;\\r\\n\\r\\nvar camera = Camera{\\r\\n    .position = vec3{0,0,20},\\r\\n    .target = vec3{0,0,0},\\r\\n    .up = vec3{0,1f,0},\\r\\n    .fov = FOV,\\r\\n    .pitch = 0,\\r\\n    .yaw = 0,\\r\\n    .roll = 0\\r\\n}\\r\\nvar projectionMatrix: mat4;\\r\\nvar transformMatrix: mat4;\\r\\nvar viewMatrix: mat4;\\r\\nvar window: GLFWwindow*;\\r\\n\\r\\nvar box = Entity {\\r\\n    .pos = vec3{0, 0, 0},\\r\\n    .rot = vec3{0, 0, 0},\\r\\n    .scale = 1f,\\r\\n    .xform = mat4{0}\\r\\n}\\r\\n\\r\\nconst MAX_CHUNKS = 10\\r\\nvar chunks: [MAX_CHUNKS]Chunk;\\r\\n\\r\\nconst GX = 40\\r\\nconst GY = 40\\r\\nconst SIZE = GY*GX\\r\\nvar ground: [SIZE]Entity;\\r\\n\\r\\nvar light = Light {\\r\\n    .pos = vec3{0, 100, 0},\\r\\n    .color = vec3{1, 1, 1},\\r\\n}\\r\\n\\r\\nfunc CmdQuit(args: char const*) {\\r\\n    isRunning = false;\\r\\n}\\r\\n\\r\\nfunc Init() {\\r\\n    camera.init()\\r\\n\\r\\n    var fragSource: char*;\\r\\n    var status = ReadFile(\\\"../assets/shaders/basicFragment.glsl\\\", &fragSource)\\r\\n\\r\\n    var vertSource: char*;\\r\\n    ReadFile(\\\"../assets/shaders/basicVertex.glsl\\\", &vertSource)\\r\\n\\r\\n    shader = LoadProgram(vertSource, fragSource)        \\r\\n    glCheckErrorPrint()\\r\\n    shader.bindAttr(AttribPos.POSITION, \\\"position\\\")\\r\\n    shader.bindAttr(AttribPos.NORMAL, \\\"normal\\\")\\r\\n    shader.bindAttr(AttribPos.TEXCOORD, \\\"texCoord\\\")\\r\\n    shader.link()\\r\\n    shader.validate()\\r\\n\\r\\n    glCheckErrorPrint()\\r\\n\\r\\n    texture = LoadTextureFromFile(\\\"../assets/texture.png\\\")\\r\\n/*    \\r\\n    printf(\\\"Width: %f Height: %f\\\\n\\\", texture.width, texture.height)\\r\\n    var indexLength = 36; // array_length<u32>(indices)\\r\\n    var dataLength =  8 * 4 * 6;// array_length<f32>(data)\\r\\n    printf(\\\"I: %d, D: %d\\\\n\\\", indexLength, dataLength)\\r\\n    LoadModel(indices, indexLength, data, dataLength, texture, &model)\\r\\n*/\\r\\n\\r\\n    LoadBlocks(texture)\\r\\n\\r\\n    var z = 0\\r\\n    var x = 0\\r\\n    for(var i = 0; i < MAX_CHUNKS; i += 1) {\\r\\n        if(i % 5 == 0) {\\r\\n            z += 1\\r\\n            x = 0\\r\\n        }\\r\\n        chunks[i].init(vec3{CHUNK_WIDTH*(x*2),0,CHUNK_DEPTH*(z*2)})\\r\\n        x += 1\\r\\n    }\\r\\n\\r\\n    //LoadOBJFromFile(\\\"../assets/skull.obj\\\", &model2)\\r\\n\\r\\n/*\\r\\n    var i = 0\\r\\n    for(var z = 0; z < GY; z+=1) {\\r\\n        for(var x = 0; x < GX; x+=1) {\\r\\n            var t = &ground[i]\\r\\n            t.pos[0] = x * 2;\\r\\n            t.pos[1] = 0;\\r\\n            t.pos[2] = z * -2;\\r\\n            t.scale = 1f\\r\\n            i+=1\\r\\n        }\\r\\n    }\\r\\n*/    \\r\\n\\r\\n    var aspectRatio = (GetWindowWidth() as (f32) / GetWindowHeight() as (f32)) as (f32);\\r\\n\\tvar yScale = ((1f / c::tan(toRadians(FOV /2f))) * aspectRatio) as (f32);\\r\\n\\tvar xScale = yScale / aspectRatio;\\r\\n    var frustumLength = FAR_PLANE - NEAR_PLANE;\\r\\n\\r\\n    glm_mat4_identity(projectionMatrix)\\r\\n    projectionMatrix[0][0] = xScale;\\r\\n    projectionMatrix[1][1] = yScale;\\r\\n    projectionMatrix[2][2] = -((FAR_PLANE + NEAR_PLANE) / frustumLength);\\r\\n    projectionMatrix[2][3] = -1;\\r\\n    projectionMatrix[3][2] = -((2 * NEAR_PLANE * FAR_PLANE) / frustumLength);\\r\\n    projectionMatrix[3][3] = 0;\\r\\n\\r\\n    printf(\\\"Aspect: %f\\\\n\\\", aspectRatio)    \\r\\n    PrintMatrix(projectionMatrix)\\r\\n\\r\\n    glm_mat4_identity(transformMatrix)\\r\\n    glm_mat4_identity(viewMatrix)  \\r\\n\\r\\n    shader.bind()\\r\\n    shader.loadMat4ByName(\\\"transformationMatrix\\\", transformMatrix)\\r\\n    shader.loadMat4ByName(\\\"projectionMatrix\\\", projectionMatrix)\\r\\n    shader.loadMat4ByName(\\\"viewMatrix\\\", viewMatrix)\\r\\n    shader.loadVec3ByName(\\\"lightPos\\\", light.pos)\\r\\n    shader.loadVec3ByName(\\\"lightColor\\\", light.color)\\r\\n    shader.unbind()\\r\\n}\\r\\n\\r\\nfunc Update(timeStep: TimeStep*) {    \\r\\n    InputSysUpdate(timeStep);\\r\\n//    ConsoleUpdate(timeStep);\\r\\n\\r\\n   // box.update(timeStep)\\r\\n    GameUpdate(timeStep)\\r\\n\\r\\n    var controls = 0\\r\\n    if(InputSysIsKeyPressed(GLFW_KEY_W)) {\\r\\n        controls |= MovementControls.MOVE_FORWARD\\r\\n    }\\r\\n    else if(InputSysIsKeyPressed(GLFW_KEY_S)) {\\r\\n        controls |= MovementControls.MOVE_BACKWARD\\r\\n    }\\r\\n\\r\\n    if(InputSysIsKeyPressed(GLFW_KEY_A)) {\\r\\n        controls |= MovementControls.MOVE_LEFT\\r\\n    }\\r\\n    else if(InputSysIsKeyPressed(GLFW_KEY_D)) {\\r\\n        controls |= MovementControls.MOVE_RIGHT\\r\\n    }\\r\\n\\r\\n    if(InputSysIsKeyPressed(GLFW_KEY_Q)) {\\r\\n        controls |= MovementControls.MOVE_UP\\r\\n    }\\r\\n    else if(InputSysIsKeyPressed(GLFW_KEY_E)) {\\r\\n        controls |= MovementControls.MOVE_DOWN\\r\\n    }\\r\\n\\r\\n    if(InputSysIsKeyPressed(GLFW_KEY_LEFT_SHIFT)) {\\r\\n        controls |= MovementControls.LEAN_LEFT\\r\\n    }\\r\\n    else if(InputSysIsKeyPressed(GLFW_KEY_SPACE)) {\\r\\n        controls |= MovementControls.LEAN_RIGHT\\r\\n    }\\r\\n\\r\\n    var m = MousePos{0,0}\\r\\n    InputSysGetMouseDeltaPos(m)\\r\\n    camera.move(controls, m[0], m[1])\\r\\n\\r\\n    glm_mat4_identity(viewMatrix)    \\r\\n    camera.viewMatrix(viewMatrix)\\r\\n}\\r\\n\\r\\nfunc Draw(alpha: f32) {\\r\\n    glViewport(0, 0, WIDTH, HEIGHT)\\r\\n    Prepare()\\r\\n\\r\\n    for(var i = 0; i < MAX_CHUNKS; i+=1) {        \\r\\n        chunks[i].draw(shader, texture, viewMatrix)\\r\\n    }\\r\\n//    BatchEntityRender(ground, SIZE, &model, shader, viewMatrix)\\r\\n//    GameDraw();\\r\\n//   ConsoleDraw();\\r\\n}\\r\\n\\r\\nfunc GetWindowWidth() : i32 {\\r\\n    if(!window) {\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    var width: i32;\\r\\n    var height: i32;\\r\\n    glfwGetWindowSize(window, &width, &height);\\r\\n    return width;\\r\\n}\\r\\n\\r\\nfunc GetWindowHeight() : i32 {\\r\\n    if(!window) {\\r\\n        return 0;\\r\\n    }\\r\\n    var width: i32;\\r\\n    var height: i32;\\r\\n    glfwGetWindowSize(window, &width, &height);\\r\\n    return height;\\r\\n}\\r\\n\\r\\nfunc main(len: i32, args: char**) : i32 {\\r\\n    glfwSetErrorCallback(errorCallback);\\r\\n    \\r\\n    if (!glfwInit()) {\\r\\n        log(LogLevel.FATAL, \\\"Failed to initialize glfw!\\\\n\\\")\\r\\n    }    \\r\\n    defer glfwTerminate();\\r\\n\\r\\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\\r\\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);\\r\\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\\r\\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\\r\\n\\r\\n    window = glfwCreateWindow(WIDTH, HEIGHT, \\\"Kraft!\\\", null, null);\\r\\n    if (!window) {\\r\\n        log(LogLevel.FATAL, \\\"Failed to initialize window context!\\\\n\\\")\\r\\n    }\\r\\n    defer glfwDestroyWindow(window);\\r\\n\\r\\n    glfwSetKeyCallback(window, keyCallback);\\r\\n    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);\\r\\n    \\r\\n    glfwMakeContextCurrent(window);\\r\\n    gladLoadGLLoader(glfwGetProcAddress as (GLADloadproc));\\r\\n    glfwSwapInterval(1);\\r\\n\\r\\n    Init()\\r\\n\\r\\n    glEnable(GL_CULL_FACE)\\r\\n    glCullFace(GL_BACK)\\r\\n    //glFrontFace(GL_CW)\\r\\n\\r\\n    var currentTime = GetTicks()\\r\\n    var accumulator = 0_i64\\r\\n    var previousTime : Time = 0_i64\\r\\n\\r\\n    const maxIterations = 10\\r\\n    const maxDelta = 250_i64\\r\\n    const frameRate = 30_i64\\r\\n    const fixedTimeStep = 1000_i64 / frameRate\\r\\n\\r\\n    const timeStep = TimeStep {\\r\\n        .frameTime: fixedTimeStep,\\r\\n        .gameClock: 0_i64,\\r\\n        .frameTimeFraction: fixedTimeStep as (f64) / 1000_f64\\r\\n    }\\r\\n\\r\\n    isRunning = true;\\r\\n\\r\\n    while (!glfwWindowShouldClose(window) && isRunning) {\\r\\n        /*\\r\\n        while(deltaTime >= fixedTimeStep) {\\r\\n            timeStep.gameClock = gameClock\\r\\n            timeStep.frameTime = deltaTime\\r\\n\\r\\n            glfwPollEvents()\\r\\n            Update(&timeStep)\\r\\n\\r\\n            deltaTime   -= fixedTimeStep\\r\\n            gameClock   += fixedTimeStep\\r\\n            currentTime += fixedTimeStep\\r\\n            \\r\\n            if(deltaTime >= 4 * fixedTimeStep) {\\r\\n                currentTime = GetTicks()\\r\\n                break;\\r\\n            }\\r\\n        }*/\\r\\n        var newTime = GetTicks()\\r\\n        var deltaTime = newTime - currentTime;\\r\\n\\r\\n        // don't let the game get too far behind\\r\\n        if(deltaTime > maxDelta) {\\r\\n            deltaTime = maxDelta;\\r\\n        }\\r\\n        \\r\\n        glfwPollEvents()\\r\\n\\r\\n        currentTime = newTime\\r\\n        accumulator += deltaTime\\r\\n        var iteration = 0\\r\\n\\r\\n        while(accumulator >= fixedTimeStep && iteration < maxIterations) {\\r\\n            Update(&timeStep)\\r\\n\\r\\n            timeStep.gameClock += fixedTimeStep\\r\\n            accumulator        -= fixedTimeStep\\r\\n            iteration          += 1                \\r\\n        }\\r\\n\\r\\n        var alpha : f32 = (accumulator as (f64) / fixedTimeStep as (f64)) as (f32)        \\r\\n        Draw(alpha)\\r\\n        glfwSwapBuffers(window);\\r\\n    }\\r\\n\\r\\n\\r\\n}\\r\\n\\r\\npublic func GetKeyState(key: i32) : i32 {\\r\\n    return glfwGetKey(window, key)\\r\\n}\\r\\n\\r\\npublic func GetMousePos(mousePos: MousePos) {\\r\\n    var x:f64;\\r\\n    var y:f64;\\r\\n\\r\\n    glfwGetCursorPos(window, &x, &y)\\r\\n\\r\\n    mousePos[0] = x as (f32)\\r\\n    mousePos[1] = y as (f32)\\r\\n\\r\\n    //printf(\\\"Mouse: %f,%f\\\\n\\\", x, y)\\r\\n}\\r\\n\\r\\npublic func GetMouseButtonState(btn: i32) : i32 {\\r\\n    return glfwGetMouseButton(window, btn)\\r\\n}\\r\\n\\r\\nfunc keyCallback(window: GLFWwindow*, key: i32, scancode: i32, action: i32, mods: i32) {\\r\\n    if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)\\r\\n        glfwSetWindowShouldClose(window, GLFW_TRUE);\\r\\n}\\r\\n\\r\\nfunc errorCallback(error: i32, description: char const*) {\\r\\n    log(LogLevel.ERROR, \\\"%s\\\", description)\\r\\n}\\r\\n\\r\\n\\r\\n\"}}}";
        //String openJson = "{\"jsonrpc\":\"2.0\",\"method\":\"textDocument/didOpen\",\"params\":{\"textDocument\":{\"uri\":\"file:///c%3A/Users/antho/git/kraft/src/test.lita\",\"languageId\":\"litac\",\"version\":1,\"text\":\"import \"math\" \\\\r\\\\nstruct X {\\r\\n    test: i32\\r\\n    blah: i32\\r\\n}\\r\\n\\r\\nfunc (x: X) fn() : i32{\\r\\n    return 0;\\r\\n}\\r\\n\\r\\nfunc test() {\\r\\n    var x = X{}\\r\\n    var t = x.fn()\\r\\n    x.test = 2;\\r\\n}\"}}}";
        String openJson = "{\"jsonrpc\":\"2.0\",\"method\":\"textDocument/didOpen\",\"params\":{\"textDocument\":{\"uri\":\"file:///c%3A/Users/antho/git/realm/src/game.lita\",\"languageId\":\"litac\",\"version\":1,\"text\":\"import \\\"io\\\"\\r\\nimport \\\"raylib\\\"\\r\\nimport \\\"raygui\\\"\\r\\nimport \\\"animation\\\"\\r\\nimport \\\"common\\\"\\r\\nimport \\\"input_system\\\"\\r\\nimport \\\"console\\\"\\r\\nimport \\\"cvars\\\"\\r\\nimport \\\"math\\\"\\r\\nimport \\\"string_buffer\\\"\\r\\nimport \\\"string_view\\\"\\r\\nimport \\\"string\\\"\\r\\nimport \\\"mem\\\"\\r\\nimport \\\"array\\\"\\r\\nimport \\\"battle_grid\\\"\\r\\nimport \\\"sprite\\\"\\r\\nimport \\\"level_loader\\\"\\r\\nimport \\\"unit_loader\\\"\\r\\nimport \\\"entity_loader\\\"\\r\\nimport \\\"model\\\"\\r\\nimport \\\"unit\\\"\\r\\nimport \\\"entity\\\"\\r\\nimport \\\"turn_manager\\\"\\r\\nimport \\\"game_ui\\\"\\r\\nimport \\\"particle_system\\\"\\r\\nimport \\\"ai\\\"\\r\\nimport \\\"script_system\\\"\\r\\nimport \\\"battle_rules\\\"\\r\\nimport \\\"draw_object\\\"\\r\\nimport \\\"libc\\\" as c\\r\\n\\r\\npublic const MAX_UNITS = 32\\r\\npublic const MAX_ENTITIES = 32\\r\\npublic const MAX_OBJECTS = MAX_UNITS + MAX_ENTITIES\\r\\n\\r\\npublic enum GameState {\\r\\n    INTRO,\\r\\n    INPROGRESS,\\r\\n    VICTORY,\\r\\n    DEFEAT,\\r\\n}\\r\\n\\r\\npublic struct Game {\\r\\n    camera: Camera2D    \\r\\n    board: BattleGrid\\r\\n\\r\\n    units: [MAX_UNITS]Unit\\r\\n    numOfUnits: i32\\r\\n\\r\\n    entities: [MAX_ENTITIES]Entity\\r\\n    numOfEntities: i32\\r\\n\\r\\n    selectedUnit: Unit*\\r\\n\\r\\n    turn: TurnManager\\r\\n    rules: BattleRules\\r\\n    state: GameState\\r\\n\\r\\n    gui: GameGui\\r\\n    ai: AISystem\\r\\n    ps: ParticleSystem\\r\\n\\r\\n    // debug\\r\\n    drawIndex: i32\\r\\n}\\r\\n\\r\\npublic var game: Game* = null\\r\\n\\r\\nfunc GameOnMouseEvent(event: MouseEvent*) : bool {   \\r\\n    if(game == null || game.selectedUnit == null) {\\r\\n        return false\\r\\n    }\\r\\n\\r\\n    var pos = GetCursorPos()\\r\\n    \\r\\n    // See if we are attacking\\r\\n    if(event.button == MouseButton.MOUSE_RIGHT_BUTTON && event.type == EventType.PRESSED) {\\r\\n        var slot = game.board.getSlotScreenPos(pos)\\r\\n        if(!slot) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        if(game.selectedUnit.canAttack(slot, game)) {\\r\\n            game.selectedUnit.attack(slot, game)\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    // See if we are moving\\r\\n    if(event.button == MouseButton.MOUSE_LEFT_BUTTON && event.type == EventType.PRESSED) {\\r\\n\\r\\n        // Used for testing out particles\\r\\n        //game.ps.spawnBloodEmitter(GetCursorPos(), RED)\\r\\n        //ExplosionAt(GetCursorPos())\\r\\n        //game.ps.spawnMusketSmokeEmitter(GetCursorPos(), Vec2{1,0})\\r\\n\\r\\n        // we have a selected unit, we are attempting to do an action\\r\\n        var slot = game.board.getSlotScreenPos(pos)\\r\\n        if(!slot) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        if(IsUnitsTurn(game.selectedUnit)) {\\r\\n            game.selectedUnit.movement(slot, game)\\r\\n        }\\r\\n        return true\\r\\n    }\\r\\n\\r\\n    return false\\r\\n}\\r\\n\\r\\nfunc GameOnKeyEvent(event: KeyEvent*) : bool {\\r\\n    if(game == null) {\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    if (event.type == EventType.RELEASED && event.keyCode == KeyboardKey.KEY_EQUAL) { \\r\\n        game.drawIndex += 1\\r\\n        return true;\\r\\n    }\\r\\n    if (event.type == EventType.RELEASED && event.keyCode == KeyboardKey.KEY_MINUS) { \\r\\n        game.drawIndex -= 1\\r\\n        return true;\\r\\n    }\\r\\n    if (event.type == EventType.RELEASED && event.keyCode == KeyboardKey.KEY_ONE) { \\r\\n        game.drawIndex = 0\\r\\n        return true;\\r\\n    }\\r\\n    if (event.type == EventType.RELEASED && event.keyCode == KeyboardKey.KEY_TWO) { \\r\\n        game.drawIndex = 1024\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    return false\\r\\n}\\r\\n\\r\\npublic func GameInit(g: Game*) {\\r\\n    game = g\\r\\n    game.camera = Camera2D {\\r\\n        .offset: Vec2{0,0}, \\r\\n        .target: Vec2{0,0},\\r\\n        .rotation: 0,\\r\\n        .zoom: 1f,\\r\\n    }\\r\\n\\r\\n    game.state = GameState.INPROGRESS\\r\\n    game.selectedUnit = null\\r\\n\\r\\n    LoadBattle(\\\"battle1\\\", game)\\r\\n\\r\\n    ScriptAPI(game)\\r\\n\\r\\n    InputSysRegisterMouseHandler(&GameOnMouseEvent)\\r\\n    InputSysRegisterKeyboardHandler(&GameOnKeyEvent)\\r\\n\\r\\n    ConsoleAddCommand(\\\"kill_unit\\\", &CmdKillUnit)\\r\\n    ConsoleAddCommand(\\\"load_battle\\\", &CmdLoadBattle)\\r\\n}\\r\\n\\r\\n\\r\\npublic func GameDestroy() {    \\r\\n    game.numOfEntities = 0\\r\\n    game.numOfUnits = 0\\r\\n\\r\\n    game.turn.destroy()\\r\\n    game.gui.destroy()\\r\\n    game.ai.destroy()\\r\\n    game.ps.destroy()\\r\\n    game.board.destroy()\\r\\n}\\r\\n\\r\\npublic func GameUpdate(timeStep: TimeStep*) {    \\r\\n    game.board.clearHover()\\r\\n    //game.board.update(timeStep)\\r\\n\\r\\n    var cursorPos = GetCursorPos()\\r\\n    game.board.hover(cursorPos)\\r\\n\\r\\n    game.ps.update(timeStep)\\r\\n\\r\\n    // make sure all bonuses are calculated, could\\r\\n    // probably do this recalculation after each action\\r\\n    // for better performance; but meh.\\r\\n    GameCalcBonuses() \\r\\n\\r\\n    var card = game.turn.currentCard()\\r\\n    if(card) {\\r\\n        if(game.selectedUnit != null) {\\r\\n            if(game.selectedUnit != card.unit) {\\r\\n                game.selectedUnit.effects.selectOff()\\r\\n\\r\\n                game.selectedUnit = card.unit\\r\\n                game.selectedUnit.effects.selectOn()\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            game.selectedUnit = card.unit\\r\\n            game.selectedUnit.effects.selectOn()\\r\\n        }\\r\\n    }\\r\\n\\r\\n    for(var i = 0; i < game.numOfEntities; i +=1) {\\r\\n        var entity = &game.entities[i]\\r\\n        entity.update(timeStep) \\r\\n    }\\r\\n\\r\\n    var endTurn = false\\r\\n\\r\\n    for(var i = 0; i < game.numOfUnits; i+=1) {\\r\\n        var unit = &game.units[i]\\r\\n        unit.update(timeStep, game)\\r\\n\\r\\n        if(unit.isDead() && IsUnitsTurn(unit)) {\\r\\n            endTurn = true\\r\\n            continue\\r\\n        }\\r\\n\\r\\n        if(!unit.isPlayersEntity && IsUnitsTurn(unit)) {        \\r\\n            var state = game.ai.takeTurn(unit)\\r\\n            if(state == TurnState.COMPLETED) {\\r\\n                endTurn = true\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    if(game.state == GameState.INTRO) {\\r\\n        return;\\r\\n    }\\r\\n    \\r\\n    var state = game.rules.checkWinCondition(timeStep, game)\\r\\n    // TEMP: For now we just have a battle, once meta-world comes\\r\\n    // into play this should be more complicated\\r\\n    switch(state) {\\r\\n        case BattleState.INPROGRESS: {\\r\\n            game.state = GameState.INPROGRESS\\r\\n            break;\\r\\n        }\\r\\n        case BattleState.VICTORY: {\\r\\n            game.state = GameState.VICTORY\\r\\n            break;\\r\\n        }\\r\\n        case BattleState.DEFEAT: {\\r\\n            game.state = GameState.DEFEAT\\r\\n            break;\\r\\n        }\\r\\n        default:{}\\r\\n    }\\r\\n\\r\\n    if(endTurn && game.state == GameState.INPROGRESS) {        \\r\\n        GameEndTurn()\\r\\n    }\\r\\n}\\r\\n\\r\\nfunc IsUnitsTurn(unit: Unit*) : bool {\\r\\n    if(!unit) return false;\\r\\n\\r\\n    var card = game.turn.currentCard()\\r\\n    if(!card) return false;\\r\\n\\r\\n    return (card.unit == unit)\\r\\n}\\r\\n\\r\\npublic func GameEndTurn() {    \\r\\n    game.turn.nextCard()\\r\\n}\\r\\n\\r\\npublic func GameGetBaseByName(name: char const*) : EntityBase* {\\r\\n    var unit = GameGetUnitByName(name)\\r\\n    if(unit) return &unit.base\\r\\n\\r\\n    var entity = GameGetEntityByName(name)\\r\\n    if(entity) return &entity.base\\r\\n\\r\\n    return null\\r\\n}\\r\\n\\r\\npublic func GameGetBaseOnSlot(slot: Slot*) : EntityBase* {\\r\\n    if(!slot) return null;\\r\\n\\r\\n    var unit = GameGetUnitOnSlot(slot)\\r\\n    if(unit) return &unit.base\\r\\n\\r\\n    var entity = GameGetEntityOnSlot(slot)\\r\\n    if(entity) return &entity.base\\r\\n\\r\\n    return null\\r\\n}\\r\\n\\r\\n\\r\\npublic func GameGetUnitByName(name: char const*) : Unit* {\\r\\n    var str = StringViewInit(name)\\r\\n\\r\\n    for(var i = 0; i < game.numOfUnits; i+=1) {\\r\\n        var unit = &game.units[i]\\r\\n        if(unit.isDead()) continue;\\r\\n\\r\\n        if(str.equals(unit.name)) {\\r\\n            return unit\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return null;\\r\\n}\\r\\n\\r\\n\\r\\npublic func GameGetEntityByName(name: char const*) : Entity* {\\r\\n    var str = StringViewInit(name)\\r\\n\\r\\n    for(var i = 0; i < game.numOfEntities; i +=1) {\\r\\n        var entity = &game.entities[i]\\r\\n        \\r\\n        if(str.equals(entity.name)) {        \\r\\n            return entity\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return null\\r\\n}\\r\\n\\r\\n\\r\\npublic func GameGetUnitOnSlot(s: Slot*) : Unit* {\\r\\n    for(var i = 0; i < game.numOfUnits; i+=1) {\\r\\n        var unit = &game.units[i]\\r\\n        if(unit.isDead()) continue;\\r\\n\\r\\n        if(unit.slot == s) {\\r\\n            return unit\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return null;\\r\\n}\\r\\npublic func GameGetEntityOnSlot(s: Slot*) : Entity* {\\r\\n    for(var i = 0; i < game.numOfEntities; i +=1) {\\r\\n        var entity = &game.entities[i]\\r\\n        if(entity.slot == s) {\\r\\n            return entity\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return null\\r\\n}\\r\\n\\r\\nfunc GameCalcBonuses() {\\r\\n\\r\\n    // clear out the board stats\\r\\n    for(var y = 0; y < MAX_BOARD_HEIGHT; y+=1) {\\r\\n        for(var x = 0; x < MAX_BOARD_WIDTH; x+=1) {\\r\\n            var slot = &game.board.slots[x][y]\\r\\n\\r\\n            // starting stats are those on the slot already\\r\\n            slot.stats.playerBonus = slot.stats.emitBonus\\r\\n            slot.stats.enemyBonus = slot.stats.emitBonus\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // first calculate the entities bonus structures\\r\\n    for(var i = 0; i < game.numOfEntities; i +=1) {\\r\\n        var entity = &game.entities[i]\\r\\n\\r\\n        GameCalcBonus(&entity.base)\\r\\n    }\\r\\n\\r\\n    // now the units\\r\\n    for(var i = 0; i < game.numOfUnits; i+=1) {\\r\\n        var unit = &game.units[i]\\r\\n        if(unit.isDead()) continue;\\r\\n\\r\\n        GameCalcBonus(&unit.base)\\r\\n    }\\r\\n        \\r\\n    // cache the bonuses on the units and entities, removing their own bonus from\\r\\n    // the calculations\\r\\n\\r\\n    for(var i = 0; i < game.numOfEntities; i +=1) {\\r\\n        var entity = &game.entities[i]\\r\\n        if(!entity.slot) continue;\\r\\n\\r\\n        if(entity.isPlayersEntity) {\\r\\n            entity.bonus = entity.slot.stats.playerBonus\\r\\n        }\\r\\n        else {\\r\\n            entity.bonus = entity.slot.stats.enemyBonus\\r\\n        }\\r\\n\\r\\n        entity.bonus.bonusAccuracy -= entity.emitBonus.bonusAccuracy\\r\\n        entity.bonus.bonusDefenseRating -= entity.emitBonus.bonusDefenseRating\\r\\n    }\\r\\n\\r\\n\\r\\n    for(var i = 0; i < game.numOfUnits; i+=1) {\\r\\n        var unit = &game.units[i]\\r\\n        if(unit.isDead()) continue;\\r\\n        \\r\\n        if(unit.isPlayersEntity) {\\r\\n            unit.bonus = unit.slot.stats.playerBonus\\r\\n        }\\r\\n        else {\\r\\n            unit.bonus = unit.slot.stats.enemyBonus\\r\\n        }\\r\\n        unit.bonus.bonusAccuracy -= unit.emitBonus.bonusAccuracy\\r\\n        unit.bonus.bonusDefenseRating -= unit.emitBonus.bonusDefenseRating\\r\\n    }\\r\\n}\\r\\n\\r\\nfunc GameCalcBonus(e: EntityBase*) {\\r\\n    if(!e.slot) return;\\r\\n\\r\\n    var d = e.emitBonus.bonusRadius\\r\\n    var sx = e.slot.x\\r\\n    var sy = e.slot.y    \\r\\n\\r\\n    for(var y = sy - d; y <= sy + d; y += 1) {\\r\\n        for(var x = sx - d; x <= sx + d; x += 1) {\\r\\n            var slot = game.board.getSlot(x, y)\\r\\n            if(!slot) {\\r\\n                continue\\r\\n            }\\r\\n\\r\\n            if(e.isPlayersEntity) {\\r\\n                slot.stats.playerBonus.bonusAccuracy += e.emitBonus.bonusAccuracy\\r\\n                slot.stats.playerBonus.bonusDefenseRating += e.emitBonus.bonusDefenseRating\\r\\n            }\\r\\n            else {\\r\\n                slot.stats.enemyBonus.bonusAccuracy += e.emitBonus.bonusAccuracy\\r\\n                slot.stats.enemyBonus.bonusDefenseRating += e.emitBonus.bonusDefenseRating\\r\\n            }\\r\\n        }\\r\\n    }    \\r\\n}\\r\\n\\r\\npublic func GameDraw() {\\r\\n    BeginMode2D(game.camera)\\r\\n    {\\r\\n        DrawObjects(game)\\r\\n\\r\\n        game.ps.draw() // TODO, should we allow emitters to be rendered at any spot?\\r\\n    }\\r\\n    EndMode2D()\\r\\n\\r\\n    game.gui.draw()\\r\\n}\\r\\n\\r\\npublic func GetCurrentUnit() : Unit* {\\r\\n    var card = game.turn.currentCard()\\r\\n    if(!card) {\\r\\n        return null\\r\\n    }\\r\\n\\r\\n    return card.unit\\r\\n}\\r\\n\\r\\npublic func GameCreateFireEntity(slot: Slot*) : Entity* {\\r\\n    if((game.numOfEntities+1) >= MAX_ENTITIES) {\\r\\n        return null\\r\\n    }\\r\\n\\r\\n    var entity = &game.entities[game.numOfEntities]\\r\\n    game.numOfEntities += 1\\r\\n\\r\\n    entity.placeOn(slot)\\r\\n    // TODO: Move Entity/Unit definitions into it's own template file\\r\\n\\r\\n}\\r\\n\\r\\npublic func LoadBattle(battleName: char const*, game: Game*) : i32 {\\r\\n    var buf:[256]char\\r\\n    var str = StringInit(buf, 256)\\r\\n\\r\\n    ConsolePrintf(\\\"Loading battle: '%s'\\\\n\\\", battleName)\\r\\n\\r\\n    GameDestroy()\\r\\n\\r\\n    str.format(\\\"../assets/levels/%s/board.json\\\", battleName)    \\r\\n    if(LoadLevel(str.str, game)) {\\r\\n        ConsolePrintf(\\\"Failed to load '%s'\\\\n\\\", str.str)\\r\\n        return -1\\r\\n    }\\r\\n   // game.\\r\\n    str.format(\\\"../assets/levels/%s/units.json\\\", battleName)    \\r\\n    if(LoadUnits(str.str, game)) {\\r\\n        ConsolePrintf(\\\"Failed to load '%s'\\\\n\\\", str.str)\\r\\n        return -1\\r\\n    }\\r\\n    \\r\\n    str.format(\\\"../assets/levels/%s/entities.json\\\", battleName)    \\r\\n    if(LoadEntities(str.str, game)) {\\r\\n        ConsolePrintf(\\\"Failed to load '%s'\\\\n\\\", str.str)\\r\\n        return -1\\r\\n    }\\r\\n\\r\\n    str.format(\\\"../assets/levels/%s/rules.json\\\", battleName)    \\r\\n    if(LoadRules(str.str, game)) {\\r\\n        ConsolePrintf(\\\"Failed to load '%s'\\\\n\\\", str.str)\\r\\n        return -1\\r\\n    }\\r\\n\\r\\n    ConsolePrintf(\\\"Successfully loaded battle: '%s'\\\\n\\\", battleName)\\r\\n    game.state = GameState.INTRO\\r\\n    \\r\\n    game.turn.init(game)\\r\\n    game.gui.init(game)\\r\\n    game.ai.init(game)\\r\\n    game.ps.init(game)\\r\\n\\r\\n    return 0\\r\\n}\\r\\n\\r\\npublic func GameStart() {\\r\\n    if(game.state == GameState.INTRO) {\\r\\n        game.state = GameState.INPROGRESS\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n    The mouse cursor in game screen coordinate space\\r\\n*/    \\r\\npublic func GetCursorPos() : Vec2 {\\r\\n    var pos = GetMousePosition()\\r\\n\\r\\n    // Get the percentage of screen space the mouse position is in\\r\\n    var xOffset = pos.x / GetScreenWidth() \\r\\n    var yOffset = pos.y / GetScreenHeight()\\r\\n\\r\\n    // now get the same percentage of game screen space; this will\\r\\n    // be our 'cursor' position\\r\\n    pos.x = gameScreenWidth * xOffset\\r\\n    pos.y = gameScreenHeight * yOffset\\r\\n   \\r\\n    return pos\\r\\n}\\r\\n\\r\\n\\r\\nfunc CmdKillUnit(args: char const*) {\\r\\n    var pos : char*\\r\\n    var index = c::strtol(args, &pos, 10) as (i32);\\r\\n    if(index < 0 || index >= game.numOfUnits) {\\r\\n        ConsolePrintf(\\\"Invalid unit index of: %d\\\\n\\\", index)    \\r\\n        return;\\r\\n    }\\r\\n    \\r\\n    var unit = &game.units[index]\\r\\n    unit.kill()\\r\\n}\\r\\n\\r\\nfunc CmdLoadBattle(args: char const*) {\\r\\n    LoadBattle(args, game)\\r\\n}\"}}}";
        RpcRequest openReq = gson.fromJson(openJson, RpcRequest.class);
        DidOpenParams openParams = gson.fromJson(openReq.params, DidOpenParams.class);
        handler.handleTextDocumentDidOpen(openReq, openParams);
        
        String docSym = "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"textDocument/documentSymbol\",\"params\":{\"textDocument\":{\"uri\":\"file:///c%3A/Users/antho/git/kraft/src/test.lita\"}}}";
        RpcRequest docReq = gson.fromJson(docSym, RpcRequest.class);
        DocumentSymbolParams docParams = gson.fromJson(docReq.params, DocumentSymbolParams.class);
//        handler.handleTextDocumentDocumentSymbol(docReq, docParams);
        
        String changeJson = "{\"jsonrpc\":\"2.0\",\"method\":\"textDocument/didChange\",\"params\":{\"textDocument\":{\"uri\":\"file:///c%3A/Users/antho/git/kraft/src/renderer.lita\",\"version\":4},\"contentChanges\":[{\"range\":{\"start\":{\"line\":6,\"character\":1},\"end\":{\"line\":6,\"character\":1}},\"rangeLength\":0,\"text\":\"/\"}]}}";
        RpcRequest changeReq = gson.fromJson(changeJson, RpcRequest.class);
        DidChangeParams changeParams = gson.fromJson(changeReq.params, DidChangeParams.class);
        //handler.handleTextDocumentDidChange(changeReq, changeParams);
        
        //String defJson = "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"textDocument/definition\",\"params\":{\"textDocument\":{\"uri\":\"file:///c%3A/Users/antho/git/kraft/src/renderer.lita\"},\"position\":{\"line\":15,\"character\":45}}}";
        //String defJson = "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"textDocument/definition\",\"params\":{\"textDocument\":{\"uri\":\"file:///c%3A/Users/antho/git/kraft/src/renderer.lita\"},\"position\":{\"line\":21,\"character\":14}}}";
        //String defJson = "{\"jsonrpc\":\"2.0\",\"id\":59,\"method\":\"textDocument/definition\",\"params\":{\"textDocument\":{\"uri\":\"file:///c%3A/Users/antho/git/kraft/src/main.lita\"},\"position\":{\"line\":54,\"character\":15}}}";
        //String defJson = "{\"jsonrpc\":\"2.0\",\"id\":3,\"method\":\"textDocument/definition\",\"params\":{\"textDocument\":{\"uri\":\"file:///c%3A/Users/antho/git/kraft/src/main.lita\"},\"position\":{\"line\":55,\"character\":18}}}";
        //String defJson = "{\"jsonrpc\":\"2.0\",\"id\":3,\"method\":\"textDocument/definition\",\"params\":{\"textDocument\":{\"uri\":\"file:///c%3A/Users/antho/git/kraft/src/main.lita\"},\"position\":{\"line\":58,\"character\":12}}}";
        //String defJson = "{\"jsonrpc\":\"2.0\",\"id\":3,\"method\":\"textDocument/definition\",\"params\":{\"textDocument\":{\"uri\":\"file:///c%3A/Users/antho/git/kraft/src/main.lita\"},\"position\":{\"line\":76,\"character\":20}}}";
        //String defJson = "{\"jsonrpc\":\"2.0\",\"id\":3,\"method\":\"textDocument/definition\",\"params\":{\"textDocument\":{\"uri\":\"file:///c%3A/Users/antho/git/kraft/src/main.lita\"},\"position\":{\"line\":103,\"character\":34}}}";
        //String defJson = "{\"jsonrpc\":\"2.0\",\"id\":2,\"method\":\"textDocument/definition\",\"params\":{\"textDocument\":{\"uri\":\"file:///c%3A/Users/antho/git/kraft/src/test.lita\"},\"position\":{\"line\":12,\"character\":8}}}";
        String defJson = "{\"jsonrpc\":\"2.0\",\"id\":9,\"method\":\"textDocument/definition\",\"params\":{\"textDocument\":{\"uri\":\"file:///c%3A/Users/antho/git/kraft/src/test.lita\"},\"position\":{\"line\":0,\"character\":9}}}";
        RpcRequest defReq = gson.fromJson(defJson, RpcRequest.class);
        TextDocumentPositionParams defParams = gson.fromJson(defReq.params, TextDocumentPositionParams.class);
        //handler.handleTextDocumentDefinition(defReq, defParams);
        
        String symbolJson = "{\"jsonrpc\":\"2.0\",\"id\":9,\"method\":\"textDocument/completion\",\"params\":{\"textDocument\":{\"uri\":\"file:///c%3A/Users/antho/git/kraft/src/test.lita\"},\"position\":{\"line\":26,\"character\":6},\"context\":{\"triggerKind\":1}}}";
        RpcRequest symReq = gson.fromJson(symbolJson, RpcRequest.class);
        WorkspaceSymbolParams symParams = gson.fromJson(symReq.params, WorkspaceSymbolParams.class);
        //handler.handleWorkspaceSymbol(symReq, symParams);
        
        
        String compJson = "{\"jsonrpc\":\"2.0\",\"id\":2,\"method\":\"textDocument/completion\",\"params\":{\"textDocument\":{\"uri\":\"file:///c%3A/Users/antho/git/realm/src/game.lita\"},\"position\":{\"line\":477,\"character\":9},\"context\":{\"triggerKind\":1}}}";
        RpcRequest compReq = gson.fromJson(compJson, RpcRequest.class);
        CompletionParams compParams = gson.fromJson(compReq.params, CompletionParams.class);
        handler.handleTextDocumentCompletion(compReq, compParams);
    }

}

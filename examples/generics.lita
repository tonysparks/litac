import "io";

/*
func <T>Max(a: T, b: T) : T {
    if(a.v > b.v) return a
    return b
}

func <T>Max2(a: T, b: T) : T {
    if(a > b) return a
    return b
}

struct Vec {
	v: i32
}

struct Vax {
    v: i32
}
*/


struct <T>Vec2 {
	x: T
	y: T
	
	/*
	union {
	  v: T
	  b: bool
	} val; */
}

func main(len:i32, args:char**):i32 {
	
	/*
    var m = <i32>Max2(32_i32, 42_i32)
	
	var m2 = <i32>Max2(532_i32, 542_i32)
	var f = <f32>Max2(3.2_f32, 4.2_f32)
	
	var v = <Vec>Max( Vec{.v:2}, Vec{1} )
	var v2 = <Vax>Max( Vax{2}, Vax{1} )
	
	
	var t = <io::Time>Max( io::Time{2_i64}, io::Time{1000_i64} )
	*/
	// typeResolver runs with the pending type, doesn't
	// get updated using the correct resolved type
	//var v : <i32>Vec2
	var vec : <f32>Vec2 = <f32>Vec2 { 3_f32, 4_f32 }
	
	/*
    io::printf("%d\n", m)
	io::printf("%d\n", m2)
	io::printf("%f\n", f)
	io::printf("%d\n", v.v)
	io::printf("%d\n", v2.v)
	io::printf("%lld\n", t.v)*/
	io::printf("%f, %f\n", vec.x, vec.y)
}